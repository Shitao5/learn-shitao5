---
title: "Mastering Shiny"
date: "2024-01-19"
date-modified: "2024-01-22"
image: "cover.png"
categories: 
  - R
---

```{r}
#| include: false
1 + 1
```

::: {.callout-note title='Progress'}
`r stfun::progress(10, 23)`

<!-- 读后感：[读《管理行为》](https://shitao5.org/posts/glxw/)。 -->
:::

::: {.callout-tip title="Learning Source"}
- <https://mastering-shiny.org/>
- <https://rstudio.github.io/cheatsheets/html/shiny.html>
:::

# Getting started {-}

# Your first Shiny app

- You can enter that URL into any compatible web browser to open another copy of your app.

- Layout functions, inputs, and outputs have different uses, but they are fundamentally the same under the covers: they’re all just fancy ways to generate HTML, and if you call any of them outside of a Shiny app, you’ll see HTML printed out at the console. Don’t be afraid to poke around to see how these various layouts and controls work under the hood.

- The essence of reactivity: outputs automatically react (recalculate) when their inputs change.

- In every kind of programming, it’s poor practice to have duplicated code; it can be computationally wasteful, and more importantly, it increases the difficulty of maintaining or debugging the code.

- You create a reactive expression by wrapping a block of code in `reactive({...})` and assigning it to a variable, and you use a reactive expression by calling it like a function. But while it looks like you’re calling a function, a reactive expression has an important difference: it only runs the first time it is called and then it caches its result until it needs to be updated.

# Basic UI

- Generally, I recommend only using sliders for small ranges, or cases where the precise value is not so important. Attempting to precisely select a number on a small slider is an exercise in frustration!

- By default, `plotOutput()` will take up the full width of its container (more on that shortly), and will be 400 pixels high. You can override these defaults with the `height` and `width` arguments. We recommend always setting `res = 96` as that will make your Shiny plots match what you see in RStudio as closely as possible.

# Basic reactivity

- The key idea of reactive programming is to specify a graph of dependencies so that when an input changes, all related outputs are automatically updated.

- The `ui` is simple because every user gets the same HTML. The `server` is more complicated because every user needs to get an independent version of the app; when user A moves a slider, user B shouldn’t see their outputs change.
  
  To achieve this independence, Shiny invokes your `server()` function each time a new session starts. Just like any other R function, when the server function is called it creates a new local environment that is independent of every other invocation of the function. This allows each session to have a unique state, as well as isolating the variables created inside the function. This is why almost all of the reactive programming you’ll do in Shiny will be inside the server function.

- Unlike a typical list, `input` objects are read-only. If you attempt to modify an input inside the server function, you’ll get an error.

- One more important thing about `input`: it’s selective about who is allowed to read it. To read from an `input`, you must be in a **reactive context** created by a function like `renderText()` or `reactive()`. It’s an important constraint that allows outputs to automatically update when an input changes.

- It’s important to understand that the order your code run is solely determined by the reactive graph. This is different from most R code where the execution order is determined by the order of lines.

- In Shiny, however, I think you should consider the rule of one: whenever you copy and paste something *once*, you should consider extracting the repeated code out into a reactive expression. The rule is stricter for Shiny because reactive expressions don’t just make it easier for humans to understand the code, they also improve Shiny’s ability to efficiently rerun code.

# Shiny in action {-}

# Workflow

- Improving workflow is a good place to invest time because it tends to pay great dividends in the long run. It doesn’t just increase the proportion of your time spent writing R code, but because you see the results more quickly, it makes the process of writing Shiny apps more enjoyable, and helps your skills improve more quickly.

- The basic idea of print debugging is to call `print()` whenever you need to understand when a part of your code is evaluated, and to show the values of important variables. We call this “print” debugging (because in most languages you’d use a print function), but In R it makes more sense to use `message()` :
  
  - `print()` is designed for displaying vectors of data so it puts quotes around strings and starts the first line with `[1]`.
  
  - `message()` sends its result to “standard error”, rather than “standard output”. These are technical terms describing output streams, which you don’t normally notice because they’re both displayed in the same way when running interactively. But if your app is hosted elsewhere, then output sent to “standard error” will be recorded in the logs.

# Layout, themes, HTML

# Graphics

- <p>For hosted apps, you also have to take into account the time needed to transmit the event from the browser to R, and then the rendered plot back from R to the browser.</p>

# User feedback

- An even simpler alternative is to use the [shinycssloaders](https://github.com/daattali/shinycssloaders) package by Dean Attali. It uses JavaScript to listen to Shiny events, so it doesn’t even need any code on the server side. Instead, you just use `shinycssloaders::withSpinner()` to wrap outputs that you want to automatically get a spinner when they have been invalidated.

- There are a few small, but important, details to consider when creating a dialog box:
  
  - What should you call the buttons? It’s best to be descriptive, so avoid yes/no or continue/cancel in favour of recapitulating the key verb.
  
  - How should you order the buttons? Do you put cancel first (like the Mac), or continue first (like Windows)? Your best option is to mirror the platform that you think most people will be using.
  
  - Can you make the dangerous option more obvious? Here I’ve used `class = "btn btn-danger"` to style the button prominently.

# Uploads and downloads

- By default, the user can only upload files up to 5 MB. You can increase this limit by setting the `shiny.maxRequestSize` option prior to starting Shiny. For example, to allow up to 10 MB run `options(shiny.maxRequestSize = 10 * 1024^2)`.

- I recommend using `.tsv` (tab separated value) instead of `.csv` (comma separated values) because many European countries use commas to separate the whole and fractional parts of a number (e.g. `1,23` vs `1.23`). This means `they can’t use commas to separate fields and instead use semi-colons in so-called “c”sv files! You can avoid this complexity by using tab separated files, which work the same way everywhere.

- By default, RMarkdown will render the report in the current process, which means that it will inherit many settings from the Shiny app (like loaded packages, options, etc). For greater robustness, I recommend running `render()` in a separate R session using the callr package:

  ```{r}
  #| eval: false
  
  render_report <- function(input, output, params) {
    rmarkdown::render(input,
      output_file = output,
      params = params,
      envir = new.env(parent = globalenv())
    )
  }
  
  server <- function(input, output) {
    output$report <- downloadHandler(
      filename = "report.html",
      content = function(file) {
        params <- list(n = input$slider)
        callr::r(
          render_report,
          list(input = report_path, output = file, params = params)
        )
      }
    )
  }
  ```

# Dynamic UI

- There are three key techniques for creating dynamic user interfaces:
  
  - Using the `update` family of functions to modify parameters of input controls.
  
  - Using `tabsetPanel()` to conditionally show and hide parts of the user interface.
  
  - Using `uiOutput()` and `renderUI()` to generate selected parts of the user interface with code.

- You might wonder when you should use `freezeReactiveValue()`: it’s actually good practice to **always** use it when you dynamically change an input `value`. The actual modification takes some time to flow to the browser then back to Shiny, and in the interim any reads of the value are at best wasted, and at worst lead to errors. Use `freezeReactiveValue()` to tell all downstream calculations that an input value is stale and they should save their effort until it’s useful.

- If you run this code yourself, you’ll notice that it takes a fraction of a second to appear after the app loads. That’s because it’s reactive: the app must load, trigger a reactive event, which calls the server function, yielding HTML to insert into the page. This is one of the downsides of `renderUI()`; relying on it too much can create a laggy UI. For good performance, strive to keep fixed as much of the user interface as possible, using the techniques described earlier in the chapter.
  
  There’s one other problem with this approach: when you change controls, you lose the currently selected value. Maintaining existing state is one of the big challenges of creating UI with code. This is one reason that selectively showing and hiding UI is a better approach if it works for you — because you’re not destroying and recreating the controls, you don’t need to do anything to preserve the values. However, in many cases, we can fix the problem by setting the value of the new input to the current `value` of the existing control:

  ```{r}
  #| eval: false
  server <- function(input, output, session) {
    output$numeric <- renderUI({
      value <- isolate(input$dynamic)
      if (input$type == "slider") {
        sliderInput("dynamic", input$label, value = value, min = 0, max = 10)
      } else {
        numericInput("dynamic", input$label, value = value, min = 0, max = 10)
      }
    })
  }
  ```

# Bookmarking

- By default, Shiny apps have one major drawback compared to most web sites: you can’t bookmark the app to return to the same place in the future or share your work with someone else with a link in an email. That’s because, by default, Shiny does not expose the current state of the app in its URL.

- There are three things we need to do to make this app bookmarkable:
  
  1. Add a `bookmarkButton()` to the UI. This generates a button that the user clicks to generate the bookmarkable URL.
  
  1. Turn `ui` into a function. You need to do this because bookmarked apps have to replay the bookmarked values: effectively, Shiny modifies the default `value` for each input control. This means there’s no longer a single static UI but multiple possible UIs that depend on parameters in the URL; i.e. it has to be a function.
  1. Add `enableBookmarking = "url"` to the `shinyApp()` call.

- Instead of providing an explicit button, another option is to automatically update the URL in the browser. This allows your users to use the user bookmark command in their browser, or copy and paste the URL from the location bar.
  
  Automatically updating the URL requires a little boilerplate in the server function:
  
  ```{r}
  #| eval: false
  # Automatically bookmark every time an input changes
  observe({
    reactiveValuesToList(input)
    session$doBookmark()
  })
  # Update the query string
  onBookmarked(updateQueryString)
  ```

# Tidy evaluation

- It’s going to be easier to understand what’s happening if we can disambiguate the two uses by introducing two new terms:
  
  - An **env-variable** (environment variable) is a “programming” variables that you create with `<-`. `input$var` is a env-variable.
  
  - A **data-variable** (data frame variables) is “statistical” variable that lives inside a data frame. `carat` is a data-variable.
  
  With these new terms we can make the problem of indirection more clear: we have a data-variable (`carat`) stored inside an env-variable (`input$var`), and we need some way to tell dplyr this. There are two slightly different ways to do this depending on whether the function you’re working with is a “data-masking” function or a “tidy-selection” function.

- Data-masking functions allow you to use variables in the “current” data frame without any extra syntax. It’s used in many dplyr functions like `arrange()`, `filter()`, `group_by()`, `mutate()`, and `summarise()`, and in ggplot2’s `aes()`. Data-masking is useful because it lets you use data-variables without any additional syntax.

- Fortunately, inside data-masking functions you can use `.data` or `.env` if you want to be explicit about whether you’re talking about a data-variable or an env-variable:
  
  ```{r}
  #| eval: false
  diamonds %>% filter(.data[[var]] > .env$min)
  ```
- However, in my opinion, one of the advantages of the tidyverse is the careful thought that has been applied to edge cases so that functions work more consistently.

- As well as data-masking, there’s one other important part of tidy evaluation: tidy-selection. Tidy-selection provides a concise way of selecting columns by position, name, or type. It’s used in `dplyr::select()` and `dplyr::across()`, and in many functions from tidyr, like `pivot_longer()`, `pivot_wider()`, `separate()`, `extract()`, and `unite()`.

- To refer to variables indirectly use `any_of()` or `all_of()`: both expect a character vector env-variable containing the names of data-variables. The only difference is what happens if you supply a variable name that doesn’t exist in the input: `all_of()` will throw an error, while `any_of()` will silently ignore it.

# Mastering reactivity {-}

# Why reactivity?

- But magic in software usually leads to disillusionment: without a solid mental model, it’s extremely difficult to predict how the software will act when you venture beyond the borders of its demos and examples. And when things don’t go the way you expect, debugging is almost impossible.

- Once you’ve formed an accurate mental model of reactivity, you’ll see that there’s nothing up Shiny’s sleeves: the magic comes from simple concepts combined in consistent ways.

- Reactive programming is a style of programming that focuses on values that change over time, and calculations and actions that depend on those values.

- For Shiny apps to be maximally useful, we need reactive expressions and outputs to update if and only if their inputs change. We want outputs to stay in sync with inputs, while ensuring that we never do more work than necessary.

- A reactive expression has two important properties:
  
  - It’s **lazy**: it doesn’t do any work until it’s called.
  
  - It’s **cached**: it doesn’t do any work the second and subsequent times it’s called because it caches the previous result.

- Spreadsheets are closely related to reactive programming: you declare the relationship between cells using formulas, and when one cell changes, all of its dependencies automatically update. So you’ve probably already done a bunch of reactive programming without knowing it!

# The reactive graph

- Recall that reactive inputs and expressions are collectively called reactive producers; reactive expressions and outputs are reactive consumers.



















