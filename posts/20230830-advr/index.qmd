---
title: "Advanced R"
date: "2023-08-30"
date-modified: "2023-08-31"
image: "cover.png"
categories: 
  - R
---

```{r}
#| include: false
1 + 1
```

::: {.callout-note title='Progress'}
`r stfun::progress(8.2, 25)`
:::

::: {.callout-tip title="Learning Source"}
- <https://adv-r.hadley.nz/index.html>
:::

# Foundations {-}

# Functions

R uses **lexical scoping**: it looks up the values of names based on how a function is defined, not how it is called. “Lexical” here is not the English adjective that means relating to words or a vocabulary. It’s a technical CS term that tells us that the scoping rules use a parse-time, rather than a run-time structure.

R’s lexical scoping follows four primary rules:

- Name masking
- Functions versus variables
- A fresh start
- Dynamic lookup

> R使用词法作用域（lexical scoping）：它根据函数的定义方式查找名称的值，而不是根据它的调用方式。“词法”在这里不是指与单词或词汇相关的英语形容词。它是一个技术性的计算机科学术语，告诉我们作用域规则使用的是解析时的结构，而不是运行时的结构。
>
> R的词法作用域遵循四条主要规则：
>
> - 名称屏蔽（Name masking）  
> - 函数与变量  
> - 全新的起点  
> - 动态查找

Lexical scoping determines where, but not when to look for values. R looks for values when the function is run, not when the function is created. Together, these two properties tell us that the output of a function can differ depending on the objects outside the function’s environment.

> 词法作用域决定了在哪里查找值，但并不决定何时查找值。R在运行函数时查找值，而不是在创建函数时。这两个属性共同告诉我们，函数的输出可能会因函数环境外部的对象而异。

Lazy evaluation is powered by a data structure called a promise, or (less commonly) a thunk. It’s one of the features that makes R such an interesting programming language.

> 惰性求值是由一个叫做 promise 的数据结构支持的，或者更少见的叫做 thunk。它是使R成为一个如此有趣的编程语言的特性之一。

You cannot manipulate promises with R code. Promises are like a quantum state: any attempt to inspect them with R code will force an immediate evaluation, making the promise disappear. Later, you’ll learn about quosures, which convert promises into an R object where you can easily inspect the expression and the environment.

> 您不能使用R代码操作 promises。Promise 就像一个量子状态：任何试图用R代码检查它们的尝试都会立即导致求值，使 promise 消失。稍后，您将了解到 quosures，它们可以将 promises 转换为R对象，您可以轻松检查表达式和环境。

An error indicates that something has gone wrong, and forces the user to deal with the problem. Some languages (like C, Go, and Rust) rely on special return values to indicate problems, but in R you should always throw an error.

> 错误表示出现了问题，并迫使用户处理这个问题。一些语言（如C、Go和Rust）依赖于特殊的返回值来表示问题，但在R中，您应该始终抛出一个错误。

# Environments

The job of an environment is to associate, or **bind**, a set of names to a set of values. You can think of an environment as a bag of names, with no implied order (i.e. it doesn’t make sense to ask which is the first element in an environment).

> 环境的作用是将一组名称与一组值关联或绑定在一起。您可以将环境视为一个名称的集合，没有隐含的顺序（即在环境中询问哪个元素是第一个元素没有意义）。

```{r}
#| message: false
library(rlang)
```

```{r}
e1 <- env(
  a = FALSE,
  b = "a",
  c = 2.3,
  d = 1:3
)

e1
```

```{r}
env_print(e1)
```

```{r}
env_names(e1)
```

To compare environments, you need to use `identical()` and not `==`. This is because `==` is a vectorised operator, and environments are not vectors.

```{r}
#| error: true
identical(global_env(), current_env())

global_env() == current_env()
```

```{r}
# Parents
e2a <- env(d = 4, e = 5)
e2b <- env(e2a, a = 1, b = 2, c = 3)

e2a
e2b
```

```{r}
# find the parent of an environment with env_parent()
env_parent(e2b)
env_parent(e2a)
```

Only one environment doesn’t have a parent: the **empty** environment.

The immediate parent of the global environment is the last package you attached, the parent of that package is the second to last package you attached, …

# Conditions

Every condition has default behaviour: errors stop execution and return to the top level, warnings are captured and displayed in aggregate, and messages are immediately displayed. Condition **handlers** allow us to temporarily override or supplement the default behaviour.

> 每个条件都有默认行为：错误会停止执行并返回到顶层，警告会被捕获并按聚合方式显示，消息会立即显示。条件处理程序允许我们临时覆盖或补充默认行为。



















































::: {.callout-tip title="To be continued"}
- <https://adv-r.hadley.nz/conditions.html#handling-conditions>
:::
