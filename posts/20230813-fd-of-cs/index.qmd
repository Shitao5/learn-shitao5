---
title: "计算机科学导论"
subtitle: "原书第4版"
date: "2023-08-13"
date-modified: "2023-08-21"
image: "cover.jpg"
categories: 
  - Computer Science
---

```{r}
#| include: false
1 + 1
```

::: {.callout-note title='Progress'}
`r stfun::progress(181, 463)`
:::

::: {.callout-tip title="Learning Source"}
- 贝赫鲁兹·佛罗赞. 计算机科学导论（原书第4版）[M]. 吕云翔, 杨洪洋, 曾洪立译. 机械工业出版社, 2020.
:::

# 绪论

## 图灵模型

- Alan Turing（阿兰·图灵）在 1936 年最先提出了一个通用计算设备的设想。他认为，所有的计算都可以在一种特殊的机器上执行，这就是现在所说的**图灵机**。

- **通用图灵机**是对现代计算机的首次描述，只要提供了合适的程序，该机器就能做任何运算。可以证明，一台很强大的计算机和通用图灵机一样能进行同样的运算。

## 冯·诺依曼模型

- 1944 ~ 1945 年，冯·诺依曼指出，鉴于程序和数据在逻辑上是相同的，因此程序也能存储在计算机的存储器中。

## 计算机组成部分

- 冯·若依曼模型要求程序必须是有序的指令集。

## 计算机科学作为一门学科

- 如同其他任何学科一样，计算机科学现在被划分成几个领域。我们可以把这些领域归纳为两大类：**系统领域**和**应用领域**。
系统领域涵盖那些与硬件和软件构成直接有关的领域，例如计算机体系结构、计算机网络、安全问题、操作系统、算法、程序设计语言以及软件工程。应用领域涵盖了与计算机使用有关的领域，例如数据库和人工智能。

# 数字系统

## 位置化数字系统

在位置化数字系统中，数字中符号所占的位置决定了其表示的值。在该系统中，数字这样表示：

$$
\pm(S_{K-1} \cdots S_2 S_1 S_0. S_{-1} S{_-2} \cdots S_{-L})_b
$$

它的值是：

$$
n = \pm \left( S_{K-1} \times b^{K-1} + \cdots + S_1 \times b^1 + S_0 \times b^0 + S_{-1} \times b^{-1} + S_{-2} \times b^{-2} + \cdots + S_{-L} \times b^{-L} \right)
$$

其中，$S$ 是一套符号集，$b$ 是底（或基数），它等于 $S$ 符号集中的符号总数，其中 $S_K$ 和 $S_L$ 分别是代表整数和小数部分的符号。

- 我们使用 $\pm$ 符号表示一个数可正可负，但这些符号并不存储在计算机中——计算机用以处理该符号的方式不同。

- 十进制不像二进制那样直接显示存储在计算机中的是什么。在二进制位数和十进制数码的数量之间没有显然的关系，它们之间的转换也不快捷。为了克服这个问题，发明了两种位置化系统：十六进制和八进制。

- 可以用数码 $K$ 表示的最大值：
  - 十进制整数的最大值为：$N_{\text{max}} = 10^K - 1$
  - 二进制整数的最大值为：$N_{\text{max}} = 2^K - 1$
  - 十六进制整数的最大值为：$N_{\text{max}} = 16^K - 1$
  - 八进制整数的最大值为：$N_{\text{max}} = 8^K - 1$

## 非位置化数字系统

非位置化数字系统仍然使用有限的数字符号，每个符号都有一个值。但是符号所占用的位置通常与其值无关——每个符号的值都是固定的。为求出该数字的值，我们把所有符号表示的值相加。比如罗马数字系统。

# 数据存储

## 数据类型

为了表示数据的不同类型，应该使用**位模式**，它是一个序列，有时也被称为**位流**。通常长度为 8 的位模式被称为 1 字节。有时用**字**这个术语指代更长的位模式。

## 存储数字

### 存储整数

- 整数通常使用顶点表示法存储在内存中。

- 只要用不到负整数，都可以用无符号整数表示法。具体情况如下：
  - 计数
  - 计算机寻址
  - 存储其他数据类型（文本、图形、音频和视频）
  
- 在符号加绝对值表示法中，最左位用于定义整数符号。0 表示正整数，1 表示负整数。在 n 位单元可存储的数字范围是 $-\left( 2^{n-1} - 1\right)$ 至 $+\left( 2^{n-1} - 1 \right)$。

- **反码运算**：反转各个位，即把 0 位变为 1 位，把 1 位变为 0 位。可应用于任何整数，无论正负。

- **补码运算**：从右边复制位，直到有 1 被复制；接着反转其余的位。另一种方法是先对它进行 1 次反码运算再加上 1 得到结果。2 次补码运算可以得到原先的整数。

- 以二进制补码格式存储整数：
  1. 将整数变成 n 位的二进制数；
  1. 如果整数是正数或零，以其原样存储；如果是负数，取其补码存储。
  
- 从二进制补码格式还原整数
  1. 如果最左位是 1，取其补码；如果最左位是 0，不进行操作；
  1. 将该整数转换为十进制。
  
- 二进制补码表示法仅有一个 0，而符号加绝对值表示法则有两个 0（+0 和 -0）。

### 实数

- 一个数字的浮点表示法由 3 部分组成：符号、位移量和定点数。

# 数据运算

## 逻辑运算

- AND 运算的一个应用就是把一个位模式的指定位复位（置 0）。这种情况下的第二个输入称为**掩码**。掩码中的 0 位对第一个输入中相应的位进行复位。掩码中的 1 位使得第一个输入中相应的位保持不变。

- OR 运算的一个应用是把一个位模式的指定位置位（置 1）。掩码中的 1 位对第一个输入中相应的位进行置位，而掩码中的 0 位使第一个输入中相应的位保持不变。

- XOR 运算的一个应用是使指定的位反转。掩码中的 1 位对第一个输入中相应的位进行反转，而掩码中的 0 位使第一个输入中相应的位保持不变。

## 移位运算

- 移位运算分为两大类：逻辑移位运算和算术移位运算。

- 算术移位运算假定位模式使用二进制补码格式表示的带符号位的证书。算术右移被用来对整数除以 2；而算术左移被用来对整数乘以 2。这些运算不应该改变符号位（最左）。算术右移保留符号位，但同时也把它复制，放入相邻的右边的位中，因此符号被保存。算术左移丢弃符号位，接受它的左边的位作为符号位。如果新的符号位与原先的相同，那么运算成功，否则发生上溢或下溢，结果是非法的。

# 计算机组成

- 计算机的组成部件可以分为三大类（或子系统）：中央处理单元（CPU）、主存储器和输入/输出子系统。

## 中央处理单元

- **中央处理单元**（CPU）用于数据的运算。在大多数体系结构中，它有三个组成部分：
  1. 算术逻辑单元（ALU）：对数据进行逻辑、移位和算术运算。
  1. 控制单元：控制各个子系统的操作。
  1. 寄存器：存放临时数据的高速独立的存储单元，CPU 的运算离不开大量寄存器的使用。可细分为数据寄存器、指令寄存器和程序计数器。

- CPU 的主要职责是：从内存中逐条取出指令，并将取出的指令存储在指令寄存器中，解释并执行指令。

## 主存储器

- **主存储器**是存储单元的集合，每一个存储单元都有唯一的标识，称为**地址**。数据以称为「字」的位组的形式在内存中传入和传出。字可以是 8 位、16 位、32 位，甚至有时是 64 位（还在增长），如果字是 8 位，一般称为 1 字节。

- 内存地址用无符号二进制整数定义。

- 随机存取存储器（RAM）与只读存储器（ROM）的区别在于，用户可读写 RAM，即用户可以在 RAM 中写信息，之后可以方便地通过覆盖来擦除原有信息。RAM 的另一个特点是易失性，当系统断电后，信息（程序或数据）将丢失。ROM 的内容是由制造商写进去的。用户只能读但不能写，它的有点是非易失性，当系统断电后，数据也不会丢失。通常用 ROM 存储关机后也不能丢失的程序或数据，例如开机时运行的程序。

## 输入/输出子系统

- 输入/输出设备可以分为两大类：非存储设备和存储设备。

- 在 **I/O 独立寻址**中，用来读/写内存的指令与用来读/写输入/输出设备的指令是完全不同的。有专门的指令完成对输入/输出设备的测试、控制以及读写操作。每个输入/输出设备有自己的地址。因为指令的不同，所以输出/输出地址可以和内存地址重叠而不会产生混淆。

- 在 **I/O 存储器映射寻址**中，CPU 将输入/输出控制器中的每一个寄存器都看作内存中的某个存储字。换言之，CPU 没有单独的指令用来表示从内存或是从输入/输出设备传送数据。

# 计算机网络和因特网

- 骨干网和供应商网络被称为**因特网服务供应商**（ISP）。骨干网通常被称为国际因特网服务供应商，供应商网络则被称为国内或地域性因特网服务供应商。

- 一个协议层（模块）可以定义为一个具有输入和输出而不需要考虑输入是如何变成输出的黑匣子。当向两台机器提供相同输入得到相同输出时，它们就可以相互替换。

- **用户数据协议**（UDP）是不可靠的无连接传输协议。它除了提供进程间通信而不是主机间通信以外，没有向网络层服务添加任何东西。

- **传输控制协议**（TCP）是一个面向连接的可靠协议。它明确定义了连接设施、数据传输和连接拆卸段以提供面向连接的数据。在传输层，TCP 将一些字节组合成叫作**段**的数据包。TCP 在每一段之前加上一个头（目的是方便控制），并且将这些段发送至网络层进行传输。

# 操作系统

- 一个作业是一个要运行的程序，一个进程则是在内存中等待分配资源的程序。

- 现代操作系统至少具有以下 4 种功能：内存管理、进程管理、设备管理、文件管理。
就像很多组织有一个部分不归任何经理管理一样，操作系统也有这样一个部分，称为用户界面或**命令解释程序**，它负责操作系统与外界的通信。

# 算法

定义：
  - 非正式：算法是一种逐步解决问题或完成任务的方法。
  - 正式：算法是一组明确步骤的有序结合，它产生结果并在有限的时间内终止。

- 可解问题的解法形式为一个可终止的算法。

<!-- 可以看一些数据结构的书 -->

- 递归解决问题有两条途径。首先将问题从高至低进行分解，然后从低到高解决它。

# 程序设计语言

## 演化

- 计算机唯一识别的语言是机器语言。

- 高级语言同汇编语言有一个共性：它们必须被转化为机器语言，这个转化过程被称为**解释**或**编译**。

## 翻译

- 高级语言程序被称为**源程序**。被翻译成的机器语言程序称为**目标程序**。有两种方法用于翻译：**编译**和**解释**。编译和解释的不同在于，编译在执行前翻译整个源代码，而解释一次只翻译和执行源代码中的一行。

- 编译程序通常把整个源程序翻译成目标程序。

- 解释是把源程序中的每一行翻译成目标程序中的行，并执行它的过程。

- 随着 Java 的到来，一种新的解释过程就被引入了。Java 语言能向任何计算机移植。为了取得可移植性，源程序到目标程序的翻译分成两步进行：编译和即使。Java 源程序首先被编译，创建 Java 的**字节代码**，字节代码看起来像机器语言中的代码，但不是任何特定计算机的目标代码，它是一种虚拟机的目标代码，该虚拟机被称为 Java 虚拟机或 JVM。字节代码然后能被任何运行 JVM 模拟器的计算机编译或解释，也就是运行字节代码的计算机只需要 JVM 模拟器，而不是 Java 编译器。





























::: {.callout-tip title="To be continued"}
- P181
:::
