{
  "hash": "6887bc6d823e9644c43a1f7790e467bb",
  "result": {
    "markdown": "---\ntitle: \"高性能MySQL\"\ndate: \"2023-07-05\"\ndate-modified: \"2023-07-15\"\nimage: \"img.jpg\"\ncategories: \"MySQL\"\n---\n\n\n\n\n::: {.callout-note title='Progress'}\nLearning Progress: Completed.😸\n:::\n\n::: {.callout-tip title=\"Learning Source\"}\n- [《高性能 MySQL》（第四版）](https://book.douban.com/subject/36096578/)\n:::\n\n# 操作系统与硬件优化\n\n- 可以通过检查 CPU 使用率来确定工作负载是否受 CPU 限制，\n但不要只查看 CPU 的总体负载，而是要查看最重要查询的 CPU 使用率和 I/O 之间的平衡，\n并注意 CPU 负载是否均匀。\n\n- 每个查询将只使用一个 CPU。\n\n- 配置大内存的主要原因并不是为了在内存中保存大量数据，\n而是为了避免磁盘 I/O，因为磁盘 I/O 比访问内存中的数据要慢几个数量级。\n\n# schema 设计与管理\n\n- 尽量避免存储 `NULL`  \n即使应用程序本身并不需要存储 `NULL` （缺失值），很多表也包含可为 `NULL` 的列，\n这是因为 `NULL` 可以是列的默认属性。通常情况下最好指定列为 `NOT NULL`，\n除非明确需要存储 `NULL` 值。\n如果查询中包含可为 `NULL` 的列，对 MySQL 来说更难优化，\n因为可为 `NULL` 的列使得索引、索引统计和值比较都更复杂。\n可为 `NULL` 的列会使用更多的存储空间，在 MySQL 里也需要特殊处理。\n通常把可为 `NULL` 的列改为 `NOT NULL` 带来的性能提升比较小，\n所以（调优时）没有必要首先在现有 schema 中查找并修改这种情况，\n除非确定这回导致问题。\n\n- 由于额外的空间需求和计算成本，应该尽量只在对小数进行精确计算时才是用 DECIMAL ——\n例如，存储财务数据。但在一些大容量的场景，可以考虑使用 BIGINT 代替 DECIMAL，\n将需要存储的货币单位根据小数的位数乘以相应的倍数即可。\n假设要存储财务数据并精确到万分之一分，则可以把所有金额乘以一百万，\n然后将结果存储在 BIGINT 里，这样可以同时避免浮点存储计算不精确和\nDECIMAL 精确计算代价高的问题。\n\n- TIMESTAMP 只使用 4 字节的存储空间，所以它的范围比 DATATIME 小得多：\n只能表示从 1970 年 到 2038 年 1 月 19 日。\n\n- MySQL 会对 NULL 值进行索引，而 Oracle 则不会。\n\n# 创建高性能的索引\n\n## 索引基础\n\n- B-tree 树的深度和表的大小直接相关。\n\n- 索引对多个值进行排序的依据是 `CREATE TABLE` 语句中定义索引时列的顺序。\n\n- InnoDB 存储引擎有一个被称为**自适应哈希索引**的特性。\n当 InnoDB 发现某些索引值被非常频繁地访问时，\n它会在原有的 B-tree 索引之上，在内存中再构建一个哈希索引。\n这就让 B-tree 索引也具备了一些哈希索引的优势。\n\n- B-tree 索引的限制：\n  - 如果不是按照索引的最左列开始查找，则无法使用索引。\n  - 不能跳过索引中的列。\n  - 如果查询中有某列的范围查找，则其右边所有列都无法使用索引优化查找。\n  \n- 总结起来索引有如下三个优点：\n  - 索引大大减少了服务器需要扫描的数据量。\n  - 索引可以帮助服务器避免排序和临时表。\n  - 索引可以将随机 I/O 变为顺序 I/O。\n  \n## 高性能的索引策略\n\n- 有时候为了提升索引的性能，同时也节省索引空间，\n可以只对字段的前一部分字符进行索引，这样做的缺点是，会降低索引的**选择性**。\n索引的选择性是指，\n不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，\n范围从 1/#T 到 1 之间。索引的选择性越高则查询效率越高，\n因为选择性高的索引可以让 MySQL 在查询时过滤掉更多的行。\n唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。\n这里的关键点在于，既要选择足够长的前缀以保证较高的选择性，\n同时又不能太长（以便节约空间）。前缀应该足够长，\n以使得前缀索引的选择性接近于索引整列。换句话说，\n前缀的“基数”应该接近于完整列的“基数”。\n\n- 前缀索引是一种能使索引更小、更快的有效办法，但它也有缺点：\nMySQL 无法使用前缀索引做 `ORDER BY` 和 `GROUP BY` 操作，\n也无法使用前缀索引做覆盖扫描。\n\n- 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，\n我们就称之为**覆盖索引**。需要注意的是，\n只有 B-tree 索引可以用于覆盖索引。\n\n# 查询性能优化\n\n- 如果我们想要知道结果中的行数，应该始终使用 `COUNT(*)`，\n这样可以更清晰地传达意图，避免糟糕的性能表现。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}