{
  "hash": "5ee91bef4c5f9969d13d992978c31504",
  "result": {
    "markdown": "---\ntitle: \"Elasticsearch 教程\"\ndate: \"2023-09-01\"\ndate-modified: \"2023-09-05\"\nimage: \"cover.jpg\"\ncategories: \n  - ES\n---\n\n\n\n\n::: {.callout-note title='Progress'}\nLearning Progress: Completed.🥇\n:::\n\n::: {.callout-tip title=\"Learning Source\"}\n- <https://www.tizi365.com/archives/590.html>\n:::\n\n# Elasticseach {-}\n\n# 简介\n\n- Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎, 国内简称ES，Elasticsearch是用java开发的，底层基于Lucene, Lucene是一种全文检索的搜索库，直接使用Lucene还是比较麻烦的，Elasticsearch在Lucene的基础上开发了一个强大的搜索引擎。\n\n- ELK代表了Elasticsearch + Logstash + Kibana 三套软件，他们的作用如下：\n\n    - Elasticsearch：前面简介提到过，解决海量数据搜索问题。\n    \n    - Logstash：解决数据同步问题，因为我们数据一般存储在Mysql之类的数据库中，需要将数据导入到ES中，Logstash就支持数据同步、数据过滤、转换功能。\n    \n    - Kibana：Elasticsearch数据可视化支持，例如：通过各种图表展示ES的查询结果，也可以在Kibana通过ES查询语句分析数据，起到类似ES Web后台的作用。\n\n# 存储结构\n\n::: {.callout-warning}\nMYSQL 是关系数据库，Elasticsearch是NOSQL类型的数据库，虽然他们都是数据库，但是他们定位不一样，也不是同一类型的数据库，拿来做对比，是因为一方面对MYSQL比较熟悉，另外从使用角度ES的存储结构跟MYSQL比较相似。\n:::\n\n- 在Elasticsearch中**索引**（index）类似mysql的表，代表**文档**（Document）数据的集合，文档指的是ES中存储的一条数据。\n\n- Elasticsearch是面向文档的数据库，文档是最基本的存储单元，文档类似mysql表中的一行数据。简单的说在ES中，文档指的就是一条JSON数据。Elasticsearch中文档使用json格式存储，因此存储上比Mysql要灵活的多，Elasticsearch支持任意格式的json数据。\n\n- 文档中的任何json字段都可以作为查询条件。文档的json格式没有严格限制，可以随意增加、减少字段，甚至每一个文档的格式都不一样也可以。\n\n- 文档由多个json字段（Field）组成， 这里的字段类似mysql中表的字段。当然Elasticsearch中字段也有类型的，下面是常用的字段类型:\n\n    - 数值类型（包括: long、integer、short、byte、double、float）\n    \n    - text：支持全文搜索\n    \n    - keyword：不支持全文搜索，例如：email、电话这些数据，作为一个整体进行匹配就可以，不需要分词处理。\n    \n    - date：日期类型\n    \n    - boolean\n\n- Elasticsearch的mapping（映射）类似mysql中的表结构定义，每个索引都有一个映射规则，我们可以通过定义索引的映射规则，提前定义好文档的json结构和字段类型，如果没有定义索引的映射规则，Elasticsearch会在写入数据的时候，根据我们写入的数据字段推测出对应的字段类型，相当于自动定义索引的映射规则。\n\n| Elasticsearch存储结构 | MYSQL存储结构 |\n| :-------------------: | :-----------: |\n| index（索引）         | 表            |\n| document（文档）      | 行，一行数据  |\n| Field（字段）         | 表字段        |\n| mapping （映射）      | 表结构定义    |\n\n: 类比MYSQL存储结构 {#tbl-es_mysql}\n\n# 文档 CRUD\n\n- 文档元数据，指的是插入JSON文档的时候，Elasticsearch为这条数据，自动生成的系统字段。元数据的字段名都是以下划线开头的。常见的元数据如下：\n\n    - _index：代表当前JSON文档所属的索引名字\n    \n    - _type：代表当前JSON文档所属的类型，虽然新版ES废弃了type的用法，但是元数据还是可以看到。\n    \n    - _id：文档唯一Id, 如果我们没有为文档指定id，系统会自动生成\n    \n    - _source：代表我们插入进去的JSON数据\n    \n    - _version：文档的版本号，每修改一次文档数据，字段就会加1， 这个字段新版的ES已经不使用了\n    \n    - _seq_no：文档的版本号, 替代老的_version字段\n    \n    - _primary_term：文档所在主分区，这个可以跟_seq_no字段搭配实现乐观锁。\n\n- 在Elasticsearch插入一个JSON文档，又叫**索引文档**， 注意这里的索引跟前面提到的文档所属的索引名，不是一回事，很晕吧，其实主要翻译问题，我们将数据插入到ES的过程，其实就是创建索引的过程，所以插入文档，也叫做索引文档，这里索引是动词， 而文档属于哪个索引（index），这里的索引代表一个分类，有数据库的概念，是个名词。搞不清楚也没关系，知道索引文档的意思，其实就是往ES插入数据就行。\n\n# 文档类型定义\n\n- 精确值通常指的就是数值类型、时间、布尔值、字符串的keyword类型，这些不可分割的数据类型，精确值搜索效率比较高，精确值匹配类似MYSQL中根据字段搜索，例如：拿一个手机号去搜索数据，对于每一个文档的手机号字段，要么相等，要么不等，不会做别的计算。\n\n- 全文类型，指的就是text类型，会涉及分词处理，存储到ES中的数据不是原始数据，是一个个关键词。例如：我们有一个title字段，数据类型是text，我们插入\"上海复旦大学\"这个字符串，经过分词处理，可能变成：\"上海\"、\"复旦大学\"、\"大学\" 这些关键词，然后根据这些关键词建倒排索引。\n\n- 查看索引映射规则：\n\n    ```json\n    GET /order/_mapping\n    ```\n\n# 查询 {-}\n\n# 基本语法结构\n\n```json\nGET /{索引名}/_search\n{\n\t\"from\" : 0,  // 返回搜索结果的开始位置\n  \t\"size\" : 10, // 分页大小，一次返回多少数据\n  \t\"_source\" :[ ...需要返回的字段数组... ],\n\t\"query\" : { ...query子句... },\n\t\"aggs\" : { ..aggs子句..  },\n\t\"sort\" : { ..sort子句..  }\n}\n```\n\n- query子句主要用来编写类似SQL的Where语句，支持布尔查询（and/or）、IN、全文搜索、模糊匹配、范围查询（大于小于）。\n\n- aggs子句，主要用来编写统计分析语句，类似SQL的group by语句。\n\n- sort子句，用来设置排序条件，类似SQL的order by语句。\n\n- ES查询的分页主要通过from和size参数设置，类似MYSQL 的limit和offset语句。\n\n- _source用于设置查询结果返回什么字段，类似Select语句后面指定字段。\n\n# query 查询\n\n## 匹配单个字段\n\n```json\nGET /{索引名}/_search\n{\n  \"query\": {\n    \"match\": {\n      \"{FIELD}\": \"{TEXT}\"\n    }\n  }\n}\n```\n\n如果title字段的数据类型是text类型，搜索关键词会进行分词处理。\n\n## 精确匹配单个字段\n\n如果我们想要类似SQL语句中的等值匹配，不需要进行分词处理，例如：订单号、手机号、时间字段，不需要分值处理，只要精确匹配。通过term实现精确匹配语法：\n\n```json\nGET /{索引名}/_search\n{\n  \"query\": {\n    \"term\": {\n      \"{FIELD}\": \"{VALUE}\"\n    }\n  }\n}\n```\n\n## 通过terms实现SQL的in语句\n\n如果我们要实现SQL中的in语句，一个字段包含给定数组中的任意一个值就匹配。terms语法：\n\n```json\nGET /order_v2/_search\n{\n  \"query\": {\n    \"terms\": {\n      \"{FIELD}\": [\n        \"{VALUE1}\",\n        \"{VALUE2}\"\n      ]\n    }\n  }\n}\n```\n\n## 范围查找\n\n通过range实现范围查询，类似SQL语句中的>, >=, <, <=表达式。range语法：\n\n```json\nGET /{索引名}/_search\n{\n  \"query\": {\n    \"range\": {\n      \"{FIELD}\": {\n        \"gte\": 10, \n        \"lte\": 20\n      }\n    }\n  }\n}\n```\n\n范围参数：\n\n- gt：大于（>）\n\n- gte：大于且等于（>=）\n\n- lt：小于（<）\n\n- lte：小于且等于（<=）\n\n## bool组合查询\n\n```json\nGET /{索引名}/_search\n{\n  \"query\": {\n    \"bool\": { // bool查询\n      \"must\": [], // must条件，类似SQL中的and, 代表必须匹配条件\n      \"must_not\": [], // must_not条件，跟must相反，必须不匹配条件\n      \"should\": [] // should条件，类似SQL中or, 代表匹配其中一个条件\n    }\n  }\n}\n```\n可以任意选择must、must_not和should条件的参数都是一个数组，意味着他们都支持设置多个条件。\n\n# 全文搜索\n\nES通过分词处理、相关度计算解决不同文章相关度对比问题。ES内置了一些相关度算法，例如：TF/IDF算法，大体上思想就是，如果一个关键词在一篇文章出现的频率高，并且在其他文章中出现的少，那说明这个关键词与这篇文章的相关度很高。\n\n分词就是为了提取搜索关键词，理解搜索的意图，我们平时在百度搜索内容的时候，输入的内容可能很长，但不是每个字都对搜索有帮助，所以通过分词算法，我们输入的搜索关键词，会进一步分解成多个关键词。\n\n在ES中测试分词效果：\n\n```json\nGET /_analyze\n{\n  \"text\": \"需要分词的内容\",\n  \"analyzer\": \"分词器\"\n}\n```\n\n目前中文分词器比较常用的有：smartcn和ik两种。smartcn是目前ES官方推荐的中文分词插件，不过目前不支持自定义词库；ik支持自定义扩展词库。\n\n# 排序\n\nES的默认排序是根据相关性分数排序，如果我们想根据查询结果中的指定字段排序，需要使用sort Processors处理。\n\n```json\nGET /{索引名}/_search\n{\n  \"query\": {\n    ...查询条件....\n  },\n  \"sort\": [\n    {\n      \"{Field1}\": { // 排序字段1\n        \"order\": \"desc\" // 排序方向，asc或者desc, 升序和降序\n      }\n    },\n    {\n      \"{Field2}\": { // 排序字段2\n        \"order\": \"desc\" // 排序方向，asc或者desc, 升序和降序\n      }\n    }\n    ....多个排序字段.....\n  ]\n}\n```\n\n# 聚合分析 {-}\n\n# 统计分析概念\n\nES聚合查询类似SQL的GROUP BY，一般统计分析主要分为两个步骤：\n\n- 分组\n\n- 组内聚合\n\n## 核心概念\n\n满足特定条件的文档的集合，叫做**桶**。桶的就是一组数据的集合，对数据分组后，得到一组组的数据，就是一个个的桶。\n\nES中桶聚合，指的就是先对数据进行分组，ES支持多种分组条件，例如：支持类似SQL的GROUP BY根据字段分组，当然ES比SQL更强大，支持更多的分组条件，以满足各种统计需求。\n\n::: {.callout-note}\n桶等同于组，分桶和分组是一个意思，ES使用桶代表一组相同特征的数据。\n:::\n\n## ES聚合查询语法\n\n```json\n{\n  \"aggregations\" : {\n    \"<aggregation_name>\" : {\n        \"<aggregation_type>\" : {\n            <aggregation_body>\n        }\n        [,\"aggregations\" : { [<sub_aggregation>]+ } ]? // 嵌套聚合查询，支持多层嵌套\n    }\n    [,\"<aggregation_name_2>\" : { ... } ]* // 多个聚合查询，每个聚合查询取不同的名字\n  }\n}\n```\n\n说明：\n\n- aggregations：代表聚合查询语句，可以简写为aggs\n\n- \\<aggregation_name\\>：代表一个聚合计算的名字，可以随意命名，因为ES支持一次进行多次统计分析查询，后面需要通过这个名字在查询结果中找到我们想要的计算结果。\n\n- \\<aggregation_type\\>：聚合类型，代表我们想要怎么统计数据，主要有两大类聚合类型，桶聚合和指标聚合，这两类聚合又包括多种聚合类型，例如：指标聚合：sum、avg， 桶聚合：terms、Date histogram等等。\n\n- \\<aggregation_body\\>：聚合类型的参数，选择不同的聚合类型，有不同的参数。\n\n- aggregation_name_2：代表其他聚合计算的名字，意思就是可以一次进行多种类型的统计。\n\n例子：\n\n```json\nGET /order/_search\n{\n    \"size\" : 0, // 设置size=0的意思就是，仅返回聚合查询结果，不返回普通query查询结果。\n    \"aggs\" : { // 聚合查询语句的简写\n        \"popular_colors\" : { // 给聚合查询取个名字，叫popular_colors\n            \"terms\" : { // 聚合类型为，terms，terms是桶聚合的一种，类似SQL的group by的作用，根据字段分组，相同字段值的文档分为一组。\n              \"field\" : \"color\" // terms聚合类型的参数，这里需要设置分组的字段为color，根据color分组\n            }\n        }\n    }\n}\n```\n\n等价SQL如下：\n\n```sql\nSELECT COUNT(color) \nFROM order\nGROUP BY color\n```\n\n# 指标聚合\n\n## 统计函数\n\nES指标聚合，就是类似SQL的统计函数，指标聚合可以单独使用，也可以跟桶聚合一起使用。\n\n常用的统计函数如下：\n\n- Value Count：类似sql的count函数，统计总数\n\n    ```json\n    GET /sales/_search?size=0\n    {\n      \"aggs\": {\n        \"types_count\": { // 聚合查询的名字，随便取个名字\n          \"value_count\": { // 聚合类型为：value_count\n            \"field\": \"type\" // 计算type这个字段值的总数\n          }\n        }\n      }\n    }\n    ```\n\n- Cardinality：类似SQL的count(DISTINCT 字段)，统计不重复的数据总数\n\n    ```json\n    POST /sales/_search?size=0\n    {\n        \"aggs\" : {\n            \"type_count\" : { // 聚合查询的名字，随便取一个\n                \"cardinality\" : { // 聚合查询类型为：cardinality\n                    \"field\" : \"type\" // 根据type这个字段统计文档总数\n                }\n            }\n        }\n    }\n    ```\n\n\n- Avg：求平均值\n\n    ```json\n    POST /exams/_search?size=0\n    {\n      \"aggs\": {\n        \"avg_grade\": { // 聚合查询名字，随便取一个名字\n          \"avg\": { // 聚合查询类型为: avg\n            \"field\": \"grade\" // 统计grade字段值的平均值\n          }\n        }\n      }\n    }\n    ```\n\n- Sum：求和（同Avg）\n\n- Max：求最大值（同Avg）\n\n- Min：求最小值（同Avg）\n\n## 综合例子\n\n实际应用中经常先通过query查询，搜索索引中的数据，然后对query查询的结果进行统计分析。\n\n```json\nGET /sales/_search\n{\n  \"size\": 0, // size = 0,代表不想返回query查询结果，只要统计结果\n  \"query\": { // 设置query查询条件，后面的aggs统计，仅对query查询结果进行统计\n    \"constant_score\": {\n      \"filter\": {\n        \"match\": {\n          \"type\": \"hat\"\n        }\n      }\n    }\n  },\n  \"aggs\": { // 统计query查询结果, 默认情况如果不写query语句，则代表统计所有数据\n    \"hat_prices\": { // 聚合查询名字，计算price总和\n      \"sum\": {\n        \"field\": \"price\"\n      }\n    },\n    \"min_price\": { // 聚合查询名字，计算price最小值\n      \"min\": { \n        \"field\": \"price\" \n      }\n    },\n    \"max_price\": { // 聚合查询名字，计算price最大值\n      \"max\": { \n        \"field\": \"price\"\n      }\n    }\n  }\n}\n```\n\n# 分组统计\n\nElasticsearch桶聚合，目的就是数据分组，先将数据按指定的条件分成多个组，然后对每一个组进行统计。 组的概念跟桶是等同的，在ES中统一使用桶（bucket）这个术语。\n\nES桶聚合的作用跟SQL的group by的作用是一样的，区别是ES支持更加强大的数据分组能力，SQL只能根据字段的唯一值进行分组，分组的数量跟字段的唯一值的数量相等，例如: group by 店铺id， 去掉重复的店铺ID后，有多少个店铺就有多少个分组。\n\n## 聚合类型\n\nES常用的桶聚合如下：\n\n- Terms聚合：类似SQL的group by，根据字段唯一值分组\n\n    ```json\n    GET /order/_search?size=0\n    {\n      \"aggs\": {\n        \"shop\": { // 聚合查询的名字，随便取个名字\n          \"terms\": { // 聚合类型为: terms\n            \"field\": \"shop_id\" // 根据shop_id字段值，分桶\n          }\n        }\n      }\n    }\n    ```\n\n- Histogram聚合：根据数值间隔分组，例如: 价格按100间隔分组，0、100、200、300等等\n\n    ```json\n    POST /sales/_search?size=0\n    {\n        \"aggs\" : {\n            \"prices\" : { // 聚合查询名字，随便取一个\n                \"histogram\" : { // 聚合类型为：histogram\n                    \"field\" : \"price\", // 根据price字段分桶\n                    \"interval\" : 50 // 分桶的间隔为50，意思就是price字段值按50间隔分组\n                }\n            }\n        }\n    }\n    ```\n\n- Date histogram聚合：根据时间间隔分组，例如：按月、按天、按小时分组\n\n    ```json\n    POST /sales/_search?size=0\n    {\n        \"aggs\" : {\n            \"sales_over_time\" : { // 聚合查询名字，随便取一个\n                \"date_histogram\" : { // 聚合类型为: date_histogram\n                    \"field\" : \"date\", // 根据date字段分组\n                    \"calendar_interval\" : \"month\", //     分组间隔：month代表每月、支持minute（每分钟）、hour（每小时）、day（每天）、week（每周）、year（每年）\n                    \"format\" : \"yyyy-MM-dd\" // 设置返回结果中桶key的时间格式\n                }\n            }\n        }\n    }\n    ```\n\n- Range聚合：按数值范围分组，例如: 0-150一组，150-200一组，200-500一组。\n\n    ```json\n    GET /_search\n    {\n       \"aggs\" : {\n            \"price_ranges\" : { // 聚合查询名字，随便取一个\n               \"range\" : { // 聚合类型为： range\n                    \"field\" : \"price\", // 根据price字段分桶\n                    \"ranges\" : [ // 范围配置\n                       { \"to\" : 100.0 }, // 意思就是 price <= 100的文档归类到一个桶\n                        { \"from\" : 100.0, \"to\" : 200.0 }, // price>100 and price<200的文档归类到一个桶\n                        { \"from\" : 200.0 } // price>200的文档归类到一个桶\n                   ]\n               }\n            }\n        }\n    }\n    ```\n\n## 综合例子\n\n```json\nGET /cars/_search\n{\n    \"size\": 0, // size=0代表不需要返回query查询结果，仅仅返回aggs统计结果\n    \"query\" : { // 设置查询语句，先赛选文档\n        \"match\" : {\n            \"make\" : \"ford\"\n        }\n    },\n    \"aggs\" : { // 然后对query搜索的结果，进行统计\n        \"colors\" : { // 聚合查询名字\n            \"terms\" : { // 聚合类型为：terms 先分桶\n              \"field\" : \"color\"\n            },\n            \"aggs\": { // 通过嵌套聚合查询，设置桶内指标聚合条件\n              \"avg_price\": { // 聚合查询名字\n                \"avg\": { // 聚合类型为: avg指标聚合\n                  \"field\": \"price\" // 根据price字段计算平均值\n                }\n              },\n              \"sum_price\": { // 聚合查询名字\n                \"sum\": { // 聚合类型为: sum指标聚合\n                  \"field\": \"price\" // 根据price字段求和\n                }\n              }\n            }\n        }\n    }\n}\n```\n\n# 多桶排序\n\n类似terms、histogram、date_histogram这类桶聚合都会动态生成多个桶，如果生成的桶特别多，我们如何确定这些桶的排序顺序，如何限制返回桶的数量。\n\n默认情况，ES会根据doc_count文档总数，降序排序。\n\nES桶聚合支持两种方式排序：\n\n- 内置排序\n\n    - _count：按文档数排序。对 terms 、 histogram 、 date_histogram 有效\n    \n    - _term：按词项的字符串值的字母顺序排序。只在 terms 内使用\n    \n    - _key：按每个桶的键值数值排序, 仅对 histogram 和 date_histogram 有效\n    \n    例子：\n    \n    ```json\n    GET /cars/_search\n    {\n       \"size\" : 0,\n       \"aggs\" : {\n            \"colors\" : { // 聚合查询名字，随便取一个\n                \"terms\" : { // 聚合类型为: terms\n                  \"field\" : \"color\", \n                  \"order\": { // 设置排序参数\n                   \"_count\" : \"asc\"  // 根据_count排序，asc升序，desc降序\n                  }\n               }\n            }\n       }\n    }\n    ```\n\n- 按度量指标排序\n\n    通常情况下，我们根据桶聚合分桶后，都会对桶内进行多个维度的指标聚合，所以我们也可以根据桶内指标聚合的结果进行排序。\n\n    ```json\n    GET /cars/_search\n    {\n       \"size\" : 0,\n       \"aggs\" : {\n           \"colors\" : { // 聚合查询名字\n                \"terms\" : { // 聚合类型: terms，先分桶\n                  \"field\" : \"color\", // 分桶字段为color\n                  \"order\": { // 设置排序参数\n                    \"avg_price\" : \"asc\"  // 根据avg_price指标聚合结果，升序排序。\n                  }\n                },\n                \"aggs\": { // 嵌套聚合查询，设置桶内聚合指标\n                    \"avg_price\": { // 聚合查询名字，前面排序引用的就是这个名字\n                        \"avg\": {\"field\": \"price\"} // 计算price字段平均值\n                    }\n                }\n            }\n        }\n    }\n    ```\n\n如果分桶的数量太多，可以通过给桶聚合增加一个size参数限制返回桶的数量：\n\n```json\nGET /_search\n{\n    \"aggs\" : {\n        \"products\" : { // 聚合查询名字\n            \"terms\" : { // 聚合类型为: terms\n                \"field\" : \"product\", // 根据product字段分桶\n                \"size\" : 5 // 限制最多返回5个桶\n            }\n        }\n    }\n}\n```\n\n# SQL {-}\n\n# SQL 简介\n\n我们可以直接通过REST API执行SQL语句，语法格式如下：\n\n```json\nPOST /_sql?format=txt\n{\n    \"query\": \"这里书写SQL语句\"\n}\n```\n\n# SQL 语法\n\nES 支持的 SQL 命令：\n\n- 查询ES索引的字段和类型\n\n    ```json\n    POST /_sql?format=txt\n    {\n       \"query\": \"SHOW COLUMNS FROM library\"\n    }\n    ```\n\n- 将ES中所有的索引都列出来\n\n    ```json\n    POST /_sql?format=txt\n    {\n        \"query\": \"SHOW TABLES\"\n    }\n    ```\n\n- 展示ES支持的SQL函数有哪些\n\n    ```json\n    POST /_sql?format=txt\n    {\n        \"query\": \"SHOW FUNCTIONS\"\n    }\n    ```\n\n# SQL 全文搜索\n\nES SQL语法虽然支持like语句，但是like并不是使用全文搜索算法，ES SQL语句中主要通过MATCH函数实现全文搜索。\n\n```json\nPOST /_sql?format=txt\n{\n    \"query\": \"SELECT author, name FROM library WHERE MATCH(author, 'frank')\"\n}\n```\n\n通过SCORE()函数实现相关度排序：\n\n```json\nPOST /_sql?format=txt\n{\n    \"query\": \"SELECT author, name FROM library WHERE MATCH(author, 'frank') ORDER BY SCORE()\"\n}\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}