{
  "hash": "b3b02afecae5bd247abedb06fa92a5d7",
  "result": {
    "markdown": "---\ntitle: \"Advanced R\"\ndate: \"2023-08-30\"\ndate-modified: \"2023-09-05\"\nimage: \"cover.png\"\ncategories: \n  - R\n---\n\n\n\n\n::: {.callout-note title='Progress'}\nLearning Progress: 37.6%.\n:::\n\n::: {.callout-tip title=\"Learning Source\"}\n- <https://adv-r.hadley.nz/index.html>\n- 中文翻译由 ChatGPT 3.5 提供\n:::\n\n# Foundations {-}\n\n# Functions\n\nR uses **lexical scoping**: it looks up the values of names based on how a function is defined, not how it is called. “Lexical” here is not the English adjective that means relating to words or a vocabulary. It’s a technical CS term that tells us that the scoping rules use a parse-time, rather than a run-time structure.\n\nR’s lexical scoping follows four primary rules:\n\n- Name masking\n- Functions versus variables\n- A fresh start\n- Dynamic lookup\n\n> R使用词法作用域（lexical scoping）：它根据函数的定义方式查找名称的值，而不是根据它的调用方式。“词法”在这里不是指与单词或词汇相关的英语形容词。它是一个技术性的计算机科学术语，告诉我们作用域规则使用的是解析时的结构，而不是运行时的结构。\n>\n> R的词法作用域遵循四条主要规则：\n>\n> - 名称屏蔽（Name masking） \n>\n> - 函数与变量  \n>\n> - 全新的起点  \n>\n> - 动态查找\n\nLexical scoping determines where, but not when to look for values. R looks for values when the function is run, not when the function is created. Together, these two properties tell us that the output of a function can differ depending on the objects outside the function’s environment.\n\n> 词法作用域决定了在哪里查找值，但并不决定何时查找值。R在运行函数时查找值，而不是在创建函数时。这两个属性共同告诉我们，函数的输出可能会因函数环境外部的对象而异。\n\nLazy evaluation is powered by a data structure called a promise, or (less commonly) a thunk. It’s one of the features that makes R such an interesting programming language.\n\n> 惰性求值是由一个叫做 promise 的数据结构支持的，或者更少见的叫做 thunk。它是使R成为一个如此有趣的编程语言的特性之一。\n\nYou cannot manipulate promises with R code. Promises are like a quantum state: any attempt to inspect them with R code will force an immediate evaluation, making the promise disappear. Later, you’ll learn about quosures, which convert promises into an R object where you can easily inspect the expression and the environment.\n\n> 您不能使用R代码操作 promises。Promise 就像一个量子状态：任何试图用R代码检查它们的尝试都会立即导致求值，使 promise 消失。稍后，您将了解到 quosures，它们可以将 promises 转换为R对象，您可以轻松检查表达式和环境。\n\nAn error indicates that something has gone wrong, and forces the user to deal with the problem. Some languages (like C, Go, and Rust) rely on special return values to indicate problems, but in R you should always throw an error.\n\n> 错误表示出现了问题，并迫使用户处理这个问题。一些语言（如C、Go和Rust）依赖于特殊的返回值来表示问题，但在R中，您应该始终抛出一个错误。\n\n# Environments\n\nThe job of an environment is to associate, or **bind**, a set of names to a set of values. You can think of an environment as a bag of names, with no implied order (i.e. it doesn’t make sense to ask which is the first element in an environment).\n\n> 环境的作用是将一组名称与一组值关联或绑定在一起。您可以将环境视为一个名称的集合，没有隐含的顺序（即在环境中询问哪个元素是第一个元素没有意义）。\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-2_f9f838f85a5ec48bf0563f2836346d35'}\n\n```{.r .cell-code}\nlibrary(rlang)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-3_d817b615cdc56843301e1b84ab491f54'}\n\n```{.r .cell-code}\ne1 <- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3\n)\n\ne1\n#> <environment: 0x000002142497fc28>\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-4_8cf12554ff951a0997a6e247128c1f87'}\n\n```{.r .cell-code}\nenv_print(e1)\n#> <environment: 0x000002142497fc28>\n#> Parent: <environment: global>\n#> Bindings:\n#> • a: <lgl>\n#> • b: <chr>\n#> • c: <dbl>\n#> • d: <int>\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-5_e34fe1bbd50fb2527c5cf219465486ef'}\n\n```{.r .cell-code}\nenv_names(e1)\n#> [1] \"a\" \"b\" \"c\" \"d\"\n```\n:::\n\n\nTo compare environments, you need to use `identical()` and not `==`. This is because `==` is a vectorised operator, and environments are not vectors.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-6_1c1497511e64328a421e0beb813de536'}\n\n```{.r .cell-code}\nidentical(global_env(), current_env())\n#> [1] TRUE\n\nglobal_env() == current_env()\n#> Error in global_env() == current_env(): comparison (==) is possible only for atomic and list types\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-7_13f44114be8486562dd8857be7921d9e'}\n\n```{.r .cell-code}\n# Parents\ne2a <- env(d = 4, e = 5)\ne2b <- env(e2a, a = 1, b = 2, c = 3)\n\ne2a\n#> <environment: 0x0000021426f1eb40>\ne2b\n#> <environment: 0x0000021426f87be8>\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-8_7a88cbcdd8ad5067f63ba9b41bef9e34'}\n\n```{.r .cell-code}\n# find the parent of an environment with env_parent()\nenv_parent(e2b)\n#> <environment: 0x0000021426f1eb40>\nenv_parent(e2a)\n#> <environment: R_GlobalEnv>\n```\n:::\n\n\nOnly one environment doesn’t have a parent: the **empty** environment.\n\nThe immediate parent of the global environment is the last package you attached, the parent of that package is the second to last package you attached, …\n\n# Conditions\n\nEvery condition has default behaviour: errors stop execution and return to the top level, warnings are captured and displayed in aggregate, and messages are immediately displayed. Condition **handlers** allow us to temporarily override or supplement the default behaviour.\n\n> 每个条件都有默认行为：错误会停止执行并返回到顶层，警告会被捕获并按聚合方式显示，消息会立即显示。条件处理程序允许我们临时覆盖或补充默认行为。\n\n`tryCatch()` registers exiting handlers, and is typically used to handle error conditions. It allows you to override the default error behaviour. For example, the following code will return `NA` instead of throwing an error:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-9_3cf45887eb17b03b1a21d45c575689b6'}\n\n```{.r .cell-code}\nf3 <- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(3)\n#> [1] 1.098612\nf3(\"x\")\n#> [1] NA\n```\n:::\n\n\nThe handlers set up by `tryCatch()` are called **exiting** handlers because after the condition is signalled, control passes to the handler and never returns to the original code, effectively meaning that the code exits.\n\n> 由 `tryCatch()` 设置的处理程序被称为**退出处理程序**，因为在条件被发出后，控制权传递给处理程序，不再返回到原始代码，实际上意味着代码退出执行。\n\n\n::: {.callout-warning}\n这章有点看不懂，暂缓。\n:::\n\n# Functional Progarmming {-}\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-10_b0f31bb18299ff8a2a2f8147128f7bbb'}\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n:::\n\n\n\nA **functional** is a function that takes a function as an input and returns a vector as output. Here's a simple functional: it calls the function provided as input with 1000 random uniform numbers. \n\n> 一个**函数式**是一个接受函数作为输入并返回向量作为输出的函数。这是一个简单的函数式示例：它使用 1000 个随机均匀数调用提供的输入函数。\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-11_e4b3cd13b0a52a37f16ebd91748543f1'}\n\n```{.r .cell-code}\nrandomise <- function(f) f(runif(1e3))\nrandomise(mean)\n#> [1] 0.5047392\nrandomise(mean)\n#> [1] 0.5213421\nrandomise(sum)\n#> [1] 500.922\n```\n:::\n\n\nThe map functions also have shortcuts for extracting elements from a vector, powered by  `purrr::pluck()`. You can use a character vector to select elements by name, an integer vector to select by position, or a list to select by both name and position. These are very useful for working with deeply nested lists, which often arise when working with JSON. \n\n> map 函数还具有从向量中提取元素的快捷方式，由 `purrr::pluck()` 提供支持。你可以使用字符向量按名称选择元素，使用整数向量按位置选择元素，或者使用列表同时按名称和位置选择元素。这在处理深层嵌套的列表时非常有用，这种情况在处理 JSON 数据时经常出现。\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-12_56d58eb7e169be442ad5ad0861f550af'}\n\n```{.r .cell-code}\nx <- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\n\n# Select by name\nmap_dbl(x, \"x\")\n#> [1] 1 4 8\n\n# Or by position\nmap_dbl(x, 1)\n#> [1] -1 -2 -3\n\n# Or both\nmap_dbl(x, list(\"y\", 1))\n#> [1] 2 5 9\n\n# You'll get an error if a component doesn't exist\nmap_chr(x, \"z\")\n#> Error in `map_chr()`:\n#> ℹ In index: 3.\n#> Caused by error:\n#> ! Result must be length 1, not 0.\n\n# Unless you supply a .default value\nmap_chr(x, \"z\", .default = NA)\n#> [1] \"a\" \"b\" NA\n```\n:::\n\n\nNote there’s a subtle difference between placing extra arguments inside an anonymous function compared with passing them to `map()`. Putting them in an anonymous function means that they will be evaluated every time `f()` is executed, not just once when you call `map()`. This is easiest to see if we make the additional argument random:\n\n> 需要注意的是，在匿名函数中放置额外的参数与将它们传递给 `map()` 之间存在微妙的差异。将它们放在匿名函数中意味着它们将在每次执行 `f()` 时被评估，而不仅仅是在调用 `map()` 时评估一次。如果我们将额外的参数设置为随机值，这一点将变得最容易理解：\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-13_ac08e6e767ac10c4795eefacb109f10d'}\n\n```{.r .cell-code}\nplus <- function(x, y) round(x + y, 2)\n\nx <- rep(0, 4)\nmap_dbl(x, plus, runif(1))\n#> [1] 0.34 0.34 0.34 0.34\nmap_dbl(x, ~ plus(.x, runif(1)))\n#> [1] 0.37 0.56 0.15 0.01\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-14_d1efcc75e4e75458fcb1ace119f40907'}\n\n```{.r .cell-code}\n# Purrr style\nby_cyl <- split(mtcars, mtcars$cyl)\n\nby_cyl %>% \n  map(~ lm(mpg ~ wt, data = .x)) %>% \n  map(coef) %>% \n  map_dbl(2)\n#>         4         6         8 \n#> -5.647025 -2.780106 -2.192438\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.callout-tip title=\"To be continued\"}\n- <https://adv-r.hadley.nz/functionals.html#map-variants>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}