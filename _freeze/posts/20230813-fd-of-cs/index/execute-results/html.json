{
  "hash": "6ef950a0024ff52f1d4a93b8a97bba77",
  "result": {
    "markdown": "---\ntitle: \"计算机科学导论\"\nsubtitle: \"原书第4版\"\ndate: \"2023-08-13\"\ndate-modified: \"2023-08-17\"\nimage: \"cover.jpg\"\ncategories: \n  - Computer Science\n---\n\n\n\n\n::: {.callout-note title='Progress'}\nLearning Progress: 16.2%.\n:::\n\n::: {.callout-tip title=\"Learning Source\"}\n- 贝赫鲁兹·佛罗赞. 计算机科学导论（原书第4版）[M]. 吕云翔, 杨洪洋, 曾洪立译. 机械工业出版社, 2020.\n:::\n\n# 绪论\n\n## 图灵模型\n\n- Alan Turing（阿兰·图灵）在 1936 年最先提出了一个通用计算设备的设想。他认为，所有的计算都可以在一种特殊的机器上执行，这就是现在所说的**图灵机**。\n\n- **通用图灵机**是对现代计算机的首次描述，只要提供了合适的程序，该机器就能做任何运算。可以证明，一台很强大的计算机和通用图灵机一样能进行同样的运算。\n\n## 冯·诺依曼模型\n\n- 1944 ~ 1945 年，冯·诺依曼指出，鉴于程序和数据在逻辑上是相同的，因此程序也能存储在计算机的存储器中。\n\n## 计算机组成部分\n\n- 冯·若依曼模型要求程序必须是有序的指令集。\n\n## 计算机科学作为一门学科\n\n- 如同其他任何学科一样，计算机科学现在被划分成几个领域。我们可以把这些领域归纳为两大类：**系统领域**和**应用领域**。\n系统领域涵盖那些与硬件和软件构成直接有关的领域，例如计算机体系结构、计算机网络、安全问题、操作系统、算法、程序设计语言以及软件工程。应用领域涵盖了与计算机使用有关的领域，例如数据库和人工智能。\n\n# 数字系统\n\n## 位置化数字系统\n\n在位置化数字系统中，数字中符号所占的位置决定了其表示的值。在该系统中，数字这样表示：\n\n$$\n\\pm(S_{K-1} \\cdots S_2 S_1 S_0. S_{-1} S{_-2} \\cdots S_{-L})_b\n$$\n\n它的值是：\n\n$$\nn = \\pm \\left( S_{K-1} \\times b^{K-1} + \\cdots + S_1 \\times b^1 + S_0 \\times b^0 + S_{-1} \\times b^{-1} + S_{-2} \\times b^{-2} + \\cdots + S_{-L} \\times b^{-L} \\right)\n$$\n\n其中，$S$ 是一套符号集，$b$ 是底（或基数），它等于 $S$ 符号集中的符号总数，其中 $S_K$ 和 $S_L$ 分别是代表整数和小数部分的符号。\n\n- 我们使用 $\\pm$ 符号表示一个数可正可负，但这些符号并不存储在计算机中——计算机用以处理该符号的方式不同。\n\n- 十进制不像二进制那样直接显示存储在计算机中的是什么。在二进制位数和十进制数码的数量之间没有显然的关系，它们之间的转换也不快捷。为了克服这个问题，发明了两种位置化系统：十六进制和八进制。\n\n- 可以用数码 $K$ 表示的最大值：\n  - 十进制整数的最大值为：$N_{\\text{max}} = 10^K - 1$\n  - 二进制整数的最大值为：$N_{\\text{max}} = 2^K - 1$\n  - 十六进制整数的最大值为：$N_{\\text{max}} = 16^K - 1$\n  - 八进制整数的最大值为：$N_{\\text{max}} = 8^K - 1$\n\n## 非位置化数字系统\n\n非位置化数字系统仍然使用有限的数字符号，每个符号都有一个值。但是符号所占用的位置通常与其值无关——每个符号的值都是固定的。为求出该数字的值，我们把所有符号表示的值相加。比如罗马数字系统。\n\n# 数据存储\n\n## 数据类型\n\n为了表示数据的不同类型，应该使用**位模式**，它是一个序列，有时也被称为**位流**。通常长度为 8 的位模式被称为 1 字节。有时用**字**这个术语指代更长的位模式。\n\n## 存储数字\n\n### 存储整数\n\n- 整数通常使用顶点表示法存储在内存中。\n\n- 只要用不到负整数，都可以用无符号整数表示法。具体情况如下：\n  - 计数\n  - 计算机寻址\n  - 存储其他数据类型（文本、图形、音频和视频）\n  \n- 在符号加绝对值表示法中，最左位用于定义整数符号。0 表示正整数，1 表示负整数。在 n 位单元可存储的数字范围是 $-\\left( 2^{n-1} - 1\\right)$ 至 $+\\left( 2^{n-1} - 1 \\right)$。\n\n- **反码运算**：反转各个位，即把 0 位变为 1 位，把 1 位变为 0 位。可应用于任何整数，无论正负。\n\n- **补码运算**：从右边复制位，直到有 1 被复制；接着反转其余的位。另一种方法是先对它进行 1 次反码运算再加上 1 得到结果。2 次补码运算可以得到原先的整数。\n\n- 以二进制补码格式存储整数：\n  1. 将整数变成 n 位的二进制数；\n  1. 如果整数是正数或零，以其原样存储；如果是负数，取其补码存储。\n  \n- 从二进制补码格式还原整数\n  1. 如果最左位是 1，取其补码；如果最左位是 0，不进行操作；\n  1. 将该整数转换为十进制。\n  \n- 二进制补码表示法仅有一个 0，而符号加绝对值表示法则有两个 0（+0 和 -0）。\n\n### 实数\n\n- 一个数字的浮点表示法由 3 部分组成：符号、位移量和定点数。\n\n# 数据运算\n\n## 逻辑运算\n\n- AND 运算的一个应用就是把一个位模式的指定位复位（置 0）。这种情况下的第二个输入称为**掩码**。掩码中的 0 位对第一个输入中相应的位进行复位。掩码中的 1 位使得第一个输入中相应的位保持不变。\n\n- OR 运算的一个应用是把一个位模式的指定位置位（置 1）。掩码中的 1 位对第一个输入中相应的位进行置位，而掩码中的 0 位使第一个输入中相应的位保持不变。\n\n- XOR 运算的一个应用是使指定的位反转。掩码中的 1 位对第一个输入中相应的位进行反转，而掩码中的 0 位使第一个输入中相应的位保持不变。\n\n## 移位运算\n\n- 移位运算分为两大类：逻辑移位运算和算术移位运算。\n\n- 算术移位运算假定位模式使用二进制补码格式表示的带符号位的证书。算术右移被用来对整数除以 2；而算术左移被用来对整数乘以 2。这些运算不应该改变符号位（最左）。算术右移保留符号位，但同时也把它复制，放入相邻的右边的位中，因此符号被保存。算术左移丢弃符号位，接受它的左边的位作为符号位。如果新的符号位与原先的相同，那么运算成功，否则发生上溢或下溢，结果是非法的。\n\n# 计算机组成\n\n- 计算机的组成部件可以分为三大类（或子系统）：中央处理单元（CPU）、主存储器和输入/输出子系统。\n\n## 中央处理单元\n\n- **中央处理单元**（CPU）用于数据的运算。在大多数体系结构中，它有三个组成部分：\n  1. 算术逻辑单元（ALU）：对数据进行逻辑、移位和算术运算。\n  1. 控制单元：控制各个子系统的操作。\n  1. 寄存器：存放临时数据的高速独立的存储单元，CPU 的运算离不开大量寄存器的使用。可细分为数据寄存器、指令寄存器和程序计数器。\n\n- CPU 的主要职责是：从内存中逐条取出指令，并将取出的指令存储在指令寄存器中，解释并执行指令。\n\n## 主存储器\n\n- **主存储器**是存储单元的集合，每一个存储单元都有唯一的标识，称为**地址**。数据以称为「字」的位组的形式在内存中传入和传出。字可以是 8 位、16 位、32 位，甚至有时是 64 位（还在增长），如果字是 8 位，一般称为 1 字节。\n\n- 内存地址用无符号二进制整数定义。\n\n- 随机存取存储器（RAM）与只读存储器（ROM）的区别在于，用户可读写 RAM，即用户可以在 RAM 中写信息，之后可以方便地通过覆盖来擦除原有信息。RAM 的另一个特点是易失性，当系统断电后，信息（程序或数据）将丢失。ROM 的内容是由制造商写进去的。用户只能读但不能写，它的有点是非易失性，当系统断电后，数据也不会丢失。通常用 ROM 存储关机后也不能丢失的程序或数据，例如开机时运行的程序。\n\n## 输入/输出子系统\n\n\n\n\n\n\n\n\n\n\n::: {.callout-tip title=\"To be continued\"}\n- P75\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}