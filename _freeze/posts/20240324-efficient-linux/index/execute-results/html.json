{
  "hash": "6d7d229a514ead56345b94c6ac5790c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Efficient Linux at the Command Line\"\nsubtitle: \"Boost Your Command-Line Skills\"\ndate: \"2024-03-24\"\n# date-modified: \"2024-03-06\"\nimage: \"cover.png\"\ncategories: \n  - Linux\n---\n\n\n\n\n::: {.callout-note title=\"Progress\"}\nLearning Progress: 4.44%.\n\n<!-- 读后感：[读《管理行为》](https://shitao5.org/posts/glxw/)。 -->\n:::\n\n::: {.callout-tip title=\"Learning Source\"}\n-   <https://book.douban.com/subject/35776782/>\n-   翻译来自 ChatGPT 3.5\n:::\n\n# **Core Concepts**\n\n## **Combining Commands**\n\n-   The Linux command line is different. Instead of big applications with tons of features, Linux supplies thousands of small commands with very few features.\n\n    > Linux命令行不同于此。与具有大量功能的大型应用程序不同，Linux提供了数千个功能很少的小型命令。\n\n-   Linux makes it easy to combine commands so their individual features work together to accomplish your goal. This way of working yields a very different mindset about computing. Instead of asking “Which app should I launch?” to achieve some result, the question becomes “Which commands should I combine?”\n\n    > Linux使得将命令组合在一起，使它们的各个功能共同完成你的目标变得很容易。这种工作方式产生了一种非常不同的计算思维。与其问“我应该启动哪个应用程序？”以实现某个结果，问题变成了“我应该组合哪些命令？”\n\n-   The vertical bar (`|`) between the commands is the Linux pipe symbol. It connects the first command’s stdout to the next command’s stdin. Any command line containing pipes is called a *pipeline*. Commands generally are not aware that they’re part of a pipeline. `ls` believes it’s writing to the display, when in fact its output has been redirected to `less`. And `less` believes it’s reading from the keyboard when it’s actually reading the output of `ls`.\n\n    > 命令之间的竖线（`|`）是Linux管道符号。它将第一个命令的标准输出连接到下一个命令的标准输入。任何包含管道的命令行都称为管道线。通常命令并不知道它们是管道线的一部分。`ls`认为它正在向显示器写入，而实际上它的输出已被重定向到`less`。`less`认为它正在从键盘读取，而实际上它正在读取`ls`的输出。\n\n-   Unlike virtually every other Linux command, `ls` is aware of whether stdout is the screen or whether it’s been redirected (to a pipe or otherwise). The reason is user-friendliness. When stdout is the screen, `ls` arranges its output in multiple columns for convenient reading. When stdout is redirected, however, `ls` produces a single column.\n\n    > 与几乎所有其他 Linux 命令不同，`ls` 能够感知到 stdout 是屏幕还是已被重定向（到管道或其他地方）。原因是为了用户友好性。当 stdout 是屏幕时，`ls` 将其输出排列成多列，方便阅读。然而，当 stdout 被重定向时，`ls` 则会生成单列。\n\n## **Introducing the Shell**\n\n-   The wildcard is handled entirely by the shell.\n\n    > 通配符完全由shell处理。\n\n-   Shell pattern matching applies only to file and directory paths. It doesn’t work for usernames, hostnames, and other types of arguments that certain commands accept.\n\n    > Shell 模式匹配仅适用于文件和目录路径。它不适用于用户名、主机名和某些命令接受的其他类型的参数。\n\n-   A variable is a name that stands in for a value. The shell also has names that stand in for commands. They’re called *aliases*.\n\n    > 变量是代表值的名称。Shell 还有代表命令的名称，它们被称为别名。\n\n    ``` bash\n    $ alias g=grep                 A command with no arguments\n    $ alias ll=\"ls -l\"             A command with arguments: quotes are required\n    ```\n\n-   Aliases take precedence over commands of the same name.\n\n    > 别名优先于同名的命令。\n\n-   Output redirection has a partner, *input redirection*, that redirects stdin to come from a file instead of the keyboard. Use the symbol `<` followed by a filename to redirect stdin.\n\n    > 输出重定向有一个伴侣，即输入重定向，它将 stdin 重定向到来自文件而不是键盘。使用符号 \\< 后跟文件名来重定向 stdin。\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}