{
  "hash": "e49cd45c1fa73aa06a4f5a5113f8f0b8",
  "result": {
    "markdown": "---\ntitle: \"Metaprogramming\"\ndate: \"2023-06-18\"\ndate-modified: \"2023-06-19\"\nimage: \"metaprogramming.png\"\ncategories: R\n---\n\n\n::: {.callout-note title='Progress'}\nLearning Progress: 60%.\n:::\n\n::: {.callout-tip title=\"Learning Source\"}\n- <https://adv-r.hadley.nz/metaprogramming.html>\n:::\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-1_d0d253a12946da2fcda853dc0ed3dacd'}\n\n```{.r .cell-code}\nlibrary(rlang)\nlibrary(lobstr)\n```\n:::\n\n\n# Big picture\n\n## Code is data\n\nThe first big idea is that **code is data**: you can capture code and compute on it as you can with any other type of data. The first way you can capture code is with `rlang::expr()`.\n\nMore formally, captured code is called an *expression*. An expression isn’t a single type of object, but is a collective term for any of four types (call, symbol, constant, or pairlist).\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-2_32a100b4510f5e1bc6c4d4d87245303a'}\n\n```{.r .cell-code}\nf <- expr(f(x = 1, y = 2))\n\n# add a new argument\nf$z <- 3\nf\n#> f(x = 1, y = 2, z = 3)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-3_80ddb617d684318e52b072431b90a073'}\n\n```{.r .cell-code}\n# remove an argument\nf[[2]] <- NULL\nf\n#> f(y = 2, z = 3)\n```\n:::\n\n\n## Code is a tree\n\nTo do more complex manipulation with expressions, you need to fully understand their structure. Behind the scenes, almost every programming language represents code as a tree, often called the **abstract syntax tree**, or AST for short. R is unusual in that you can actually inspect and manipulate this tree.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-4_48716606578f7b47d9e796c610d73791'}\n\n```{.r .cell-code}\nast(f(a, \"b\"))\n#> █─f \n#> ├─a \n#> └─\"b\"\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-5_27a6a9b5f21317b135eb735e7ed0028f'}\n\n```{.r .cell-code}\nast(f1(f2(a, b), f3(1, f4(2))))\n#> █─f1 \n#> ├─█─f2 \n#> │ ├─a \n#> │ └─b \n#> └─█─f3 \n#>   ├─1 \n#>   └─█─f4 \n#>     └─2\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-6_5ee3e0785652137f8de57c01d2a43a4d'}\n\n```{.r .cell-code}\nast(1 + 2 * 3)\n#> █─`+` \n#> ├─1 \n#> └─█─`*` \n#>   ├─2 \n#>   └─3\n```\n:::\n\n\n## Code can generate code\n\n`rlang::call2()` constructs a function call from its components: the function to call, and the arguments to call it with.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-7_46cb15eda91076af3e686fb7c82803a6'}\n\n```{.r .cell-code}\ncall2(\"f\", 1, 2, 3)\n#> f(1, 2, 3)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-8_34fe6c4c352ba11744570312f858aaba'}\n\n```{.r .cell-code}\ncall2(\"+\", 1, call2(\"*\", 2, 3))\n#> 1 + 2 * 3\n```\n:::\n\n\n`call2()` is often convenient to program with, but is a bit clunky for interactive use. An alternative technique is to build complex code trees by combining simpler code trees with a template. `expr()` and `enexpr()` have built-in support for this idea via `!!` (pronounced bang-bang), the **unquote operator**.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-9_c53f160ab76b260589b6889c7f9c9eff'}\n\n```{.r .cell-code}\nxx <- expr(x + x)\nyy <- expr(y + y)\n\nexpr(!!xx / !!yy)\n#> (x + x)/(y + y)\n```\n:::\n\n\nUnquoting gets even more useful when you wrap it up into a function, first using `enexpr()` to capture the user’s expression, then `expr()` and `!!` to create a new expression using a template. The example below shows how you can generate an expression that computes the coefficient of variation:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-10_6bde341dd8354d4394f913a3d47e3d74'}\n\n```{.r .cell-code}\ncv <- function(var) {\n  var <- enexpr(var)\n  expr(sd(!!var) / mean(!!var))\n}\n\ncv(x)\n#> sd(x)/mean(x)\ncv(x + y)\n#> sd(x + y)/mean(x + y)\n```\n:::\n\n\n## Evaluation runs code\n\nInspecting and modifying code gives you one set of powerful tools. You get another set of powerful tools when you **evaluate**, i.e. execute or run, an expression. Evaluating an expression requires an environment, which tells R what the symbols in the expression mean.\n\nThe primary tool for evaluating expressions is `base::eval()`, which takes an expression and an environment:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-11_3930563b512ec9cb7344dadc59144bf0'}\n\n```{.r .cell-code}\neval(expr(x + y), env(x = 1, y = 10))\n#> [1] 11\neval(expr(x + y), env(x = 2, y = 100))\n#> [1] 102\n```\n:::\n\n\nIf you omit the environment, `eval` uses the current environment:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-12_0b6290d027dc2640088aeb27eca675a3'}\n\n```{.r .cell-code}\nx <- 10\ny <- 100\neval(expr(x + y))\n#> [1] 110\n```\n:::\n\n\n## Customising evaluation with functions\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-13_3b84871a376e7b4b28188c1de9255a00'}\n\n```{.r .cell-code}\nstring_math <- function(x) {\n  e <- env(\n    caller_env(),\n    `+` = function(x, y) paste0(x, y),\n    `*` = function(x, y) strrep(x, y)\n  )\n  \n  eval(enexpr(x), e)\n}\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-14_4b7daab849b09759758dcf31a03e6952'}\n\n```{.r .cell-code}\nname <- \"shitao\"\nstring_math(\"Hello \" + name)\n#> [1] \"Hello shitao\"\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-15_e5c0eb8365b29a1751cdc6a340486220'}\n\n```{.r .cell-code}\nstring_math((\"x\" * 2 + \"-y\") * 3)\n#> [1] \"xx-yxx-yxx-y\"\n```\n:::\n\n\n## Customising evaluation with data\n\nAs well as expression and environment, `eval_tidy()` also takes a **data mask**, which is typically a data frame:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-16_a1a3f9857822fa1d8a39fd558589a093'}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:5, y = sample(5))\neval_tidy(expr(x + y), df)\n#> [1]  4  4  4  8 10\n```\n:::\n\n\nWe can wrap this pattern up into a function by using `enexpr()`. This gives us a function very similar to `base::with()`:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-17_69bcf1fafe511f39142d28ac589dfa5a'}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  eval_tidy(enexpr(expr), df)\n}\n\nwith2(df, x + y)\n#> [1]  4  4  4  8 10\n```\n:::\n\n\nUnfortunately, this function has a subtle bug and we need a new data structure to help deal with it.\n\n## Quosures\n\nTo make the problem more obvious, I’m going to modify `with2()`. The basic problem still occurs without this modification but it’s much harder to see.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-18_90e7dcd2a7c4897752c6c7c52fb6d326'}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  a <- 1000\n  eval_tidy(enexpr(expr), df)\n}\n\ndf <- data.frame(x = 1:3)\na <- 10\nwith2(df, x + a)\n#> [1] 1001 1002 1003\n```\n:::\n\n\nFortunately we can solve this problem by using a new data structure: the **quosure** which bundles an expression with an environment. eval_tidy() knows how to work with quosures so all we need to do is switch out enexpr() for enquo():\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-19_bb6b65aa49a020401469f1e58e52c103'}\n\n```{.r .cell-code}\nwith2 <- function(df, expr) {\n  a <- 1000\n  eval_tidy(enquo(expr), df)\n}\n\nwith2(df, x + a)\n#> [1] 11 12 13\n```\n:::\n\n\nWhenever you use a data mask, you must always use `enquo()` instead of `enexpr()`.\n\n# Expressions\n\n`expr()` returns an expression, an object that captures the structure of the code without evaluating it (i.e. running it). If you have an expression, you can evaluate it with `base::eval()`:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-20_6231260b7a1e9253cc806605941c2502'}\n\n```{.r .cell-code}\nz <- expr(y <- x * 10)\nx <- 4\neval(z)\ny\n#> [1] 40\n```\n:::\n\n\n## Abstract syntax trees\n\nExpressions are also called **abstract syntax trees** (ASTs) because the structure of code is hierarchical and can be naturally represented as a tree. Understanding this tree structure is crucial for inspecting and modifying expressions (i.e. metaprogramming).\n\n### Exercises\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-21_ce808a2f9cfa5106fd3a7aab57bb94a1'}\n\n```{.r .cell-code}\nast(f(g(h())))\n#> █─f \n#> └─█─g \n#>   └─█─h\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-22_0e7476d99d9cb54934275efea737139e'}\n\n```{.r .cell-code}\nast(`+`(`+`(1, 2), 3))\n#> █─`+` \n#> ├─█─`+` \n#> │ ├─1 \n#> │ └─2 \n#> └─3\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-23_cbaa3828a23afe31286ffc395981634f'}\n\n```{.r .cell-code}\nast(`*`(`(`(`+`(x, y)), z))\n#> █─`*` \n#> ├─█─`(` \n#> │ └─█─`+` \n#> │   ├─x \n#> │   └─y \n#> └─z\n```\n:::\n\n\n## Expressions\n\nYou can create a symbol in two ways: by capturing code that references an object with `expr()`, or turning a string into a symbol with `rlang::sym()`:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-24_ee9de6102210b4b58b64623d50f9f89e'}\n\n```{.r .cell-code}\nexpr(x)\n#> x\nsym(\"x\")\n#> x\n```\n:::\n\n\nYou can turn a symbol back into a string with `as.character()` or `rlang::as_string()`. `as_string()` has the advantage of clearly signalling that you’ll get a character vector of length 1.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-25_1138ec8d4251239557a22f0437b51520'}\n\n```{.r .cell-code}\nas_string(expr(x))\n#> [1] \"x\"\n```\n:::\n\n\n## Parsing and grammar\n\nWe’ve talked a lot about expressions and the AST, but not about how expressions are created from code that you type (like `\"x + y\"`). The process by which a computer language takes a string and constructs an expression is called **parsing**, and is governed by a set of rules known as a **grammar**.\n\nProgramming languages use conventions called operator precedence to resolve this ambiguity. We can use `ast()` to see what R does:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-26_33c8532dcaa5e1a09b11426880d4dbc5'}\n\n```{.r .cell-code}\nast(1 + 2 * 3)\n#> █─`+` \n#> ├─1 \n#> └─█─`*` \n#>   ├─2 \n#>   └─3\n```\n:::\n\n\nMost of the time you type code into the console, and R takes care of turning the characters you’ve typed into an AST. But occasionally you have code stored in a string, and you want to parse it yourself. You can do so using `rlang::parse_expr()`:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-27_078fb10a8a880f937302f1d956b159a5'}\n\n```{.r .cell-code}\nx1 <- \"y <- x + 10\"\nx1\n#> [1] \"y <- x + 10\"\nis.call(x1)\n#> [1] FALSE\n\nx2 <- parse_expr(x1)\nx2\n#> y <- x + 10\nis.call(x2)\n#> [1] TRUE\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-28_ad68b07d710c204b0db6df76b65aa692'}\n\n```{.r .cell-code}\nx3 <- \"a <- 1; a + 1\"\nparse_exprs(x3)\n#> [[1]]\n#> a <- 1\n#> \n#> [[2]]\n#> a + 1\n```\n:::\n\n\n# Quasiquotation\n\nNow that you understand the tree structure of R code, it’s time to return to one of the fundamental ideas that make `expr()` and `ast()` work: quotation. In tidy evaluation, all quoting functions are actually quasiquoting functions because they also support unquoting. Where **quotation** is the act of capturing an unevaluated expression, **unquotation** is the ability to selectively evaluate parts of an otherwise quoted expression. Together, this is called quasiquotation. Quasiquotation makes it easy to create functions that combine code written by the function’s author with code written by the function’s user. This helps to solve a wide variety of challenging problems.\n\nQuasiquotation is one of the three pillars of tidy evaluation. You’ll learn about the other two (quosures and the data mask) in Chapter 20. When used alone, quasiquotation is most useful for programming, particularly for generating code. But when it’s combined with the other techniques, tidy evaluation becomes a powerful tool for data analysis.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-29_f97377ee28110490969958eef438c0c7'}\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-30_ae19285f8b9d34d5bcabcc94aa00b4a6'}\n\n```{.r .cell-code}\ncement <- function(...) {\n  args <- ensyms(...)\n  paste(map(args, as_string), collapse = \" \")\n}\n\ncement(Good, morning, Shitao5)\n#> [1] \"Good morning Shitao5\"\ncement(Good, afternoon, Shitao5)\n#> [1] \"Good afternoon Shitao5\"\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-31_4e9380dba1749fa6529aa25857a2f512'}\n\n```{.r .cell-code}\nname <- \"Shitao5\"\ntime <- \"morning\"\n\ncement(Good, time, name)\n#> [1] \"Good time name\"\ncement(Good, !!time, !!name)\n#> [1] \"Good morning Shitao5\"\n```\n:::\n\n\nThe distinction between quoted and evaluated arguments is important:\n\n- An **evaluated** argument obeys R’s usual evaluation rules.\n\n- A **quoted** argument is captured by the function, and is processed in some custom way.\n\n`paste()` evaluates all its arguments; `cement()` quotes all its arguments.\n\nTalking about whether an argument is quoted or evaluated is a more precise way of stating whether or not a function uses non-standard evaluation (NSE). I will sometimes use “quoting function” as short-hand for a function that quotes one or more arguments, but generally, I’ll talk about quoted arguments since that is the level at which the difference applies.\n\n## Quoting\n\n### Capturing expressions\n\n`expr()` is great for interactive exploration, because it captures what you, the developer, typed. It’s not so useful inside a function:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-32_f760988124ceec1d0d2d94aa4d04f118'}\n\n```{.r .cell-code}\nf1 <- function(x) expr(x)\nf1(a + b + c)\n#> x\n```\n:::\n\n\nWe need another function to solve this problem: `enexpr()`. This captures what the caller supplied to the function by looking at the internal promise object that powers lazy evaluation.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-33_7c0a9b36ba0fe3d2be047e2f6726ec4e'}\n\n```{.r .cell-code}\nf2 <- function(x) enexpr(x)\nf2(a + b + c)\n#> a + b + c\n```\n:::\n\n\nTo capture all arguments in `...`, use `enexprs()`.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-34_81752a04843444837398e37d239abf13'}\n\n```{.r .cell-code}\nf <- function(...) enexprs(...)\nf(x = 1, y = 10 * z)\n#> $x\n#> [1] 1\n#> \n#> $y\n#> 10 * z\n```\n:::\n\n\nFinally, `exprs()` is useful interactively to make a list of expressions:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-35_9ab698ebaa361aab5fd2e9550463d7b7'}\n\n```{.r .cell-code}\nexprs(x = x ^ 2, y = y ^ 3, z = z ^ 4)\n#> $x\n#> x^2\n#> \n#> $y\n#> y^3\n#> \n#> $z\n#> z^4\n# shorthand for\n# list(x = expr(x ^ 2), y = expr(y ^ 3), z = expr(z ^ 4))\n```\n:::\n\n\nIn short, use `enexpr()` and `enexprs()` to capture the expressions supplied as arguments by the user. Use `expr()` and `exprs()` to capture expressions that you supply.\n\n### Capturing symbols\n\nSometimes you only want to allow the user to specify a variable name, not an arbitrary expression. In this case, you can use `ensym()` or `ensyms()`. These are variants of enexpr() and enexprs() that check the captured expression is either symbol or a string (which is converted to a symbol). `ensym()` and `ensyms()` throw an error if given anything else.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-36_017afdd279db920034b8745dfb3e6fc3'}\n\n```{.r .cell-code}\nf <- function(...) ensyms(...)\nf(x)\n#> [[1]]\n#> x\nf(\"x\")\n#> [[1]]\n#> x\n```\n:::\n\n\n### Summary\n\n|      | Developer | User        |\n|------|---------- |-------------|\n| One  | `expr()`  | `enexpr()`  |\n| Many | `exprs()` | `enexprs()` |\n\n: rlang quasiquoting functions {#tbl-rlang-quasiquoting}\n\n## Unquoting\n\nUnquoting allows you to selectively evaluate parts of the expression that would otherwise be quoted, which effectively allows you to merge ASTs using a template AST.\n\nUnquoting is one inverse of quoting. It allows you to selectively evaluate code inside `expr()`, so that `expr(!!x)` is equivalent to `x`. In Chapter 20, you’ll learn about another inverse, evaluation. This happens outside `expr()`, so that `eval(expr(x))` is equivalent to `x`.\n\n### Unquoting one argument\n\nUse `!!` to unquote a single argument in a function call. `!!` takes a single expression, evaluates it, and inlines the result in the AST.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-37_72627e269dee6424e19e6d9e93e119b5'}\n\n```{.r .cell-code}\nx <- expr(-1)\nexpr(f(!!x, y))\n#> f(-1, y)\n```\n:::\n\n\nAs well as call objects, `!!` also works with symbols and constants:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-38_10806ee70be51a33238380ad0dd326c5'}\n\n```{.r .cell-code}\na <- sym(\"y\")\nb <- 1\nexpr(f(!!a, !!b))\n#> f(y, 1)\n```\n:::\n\n\nIf the right-hand side of !! is a function call, !! will evaluate it and insert the results:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-39_72b74dce8955897de4a42483a3148b0c'}\n\n```{.r .cell-code}\nmean_rm <- function(var) {\n  var <- ensym(var)\n  expr(mean(!!var, na.rm = TRUE))\n}\nexpr(!!mean_rm(x) + !!mean_rm(y))\n#> mean(x, na.rm = TRUE) + mean(y, na.rm = TRUE)\n```\n:::\n\n\n### Unquoting a function\n\n`!!` is most commonly used to replace the arguments to a function, but you can also use it to replace the function. The only challenge here is operator precedence: `expr(!!f(x, y))` unquotes the result of `f(x, y)`, so you need an extra pair of parentheses.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-40_4b2c12b67167fa8457b6bc1a77fe1711'}\n\n```{.r .cell-code}\nf <- expr(foo)\nexpr((!!f)(x, y))\n#> foo(x, y)\n```\n:::\n\n\nThis also works when `f` is a call:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-41_893867b8e1467376d88164558871bd3b'}\n\n```{.r .cell-code}\nf <- expr(pkg::foo)\nexpr((!!f)(x, y))\n#> pkg::foo(x, y)\n```\n:::\n\n\nBecause of the large number of parentheses involved, it can be clearer to use `rlang::call2()`:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-42_06c38b6d0bbfd45e0e1ac4e318dcde71'}\n\n```{.r .cell-code}\nf <- expr(pkg::foo)\ncall2(f, expr(x), expr(y))\n#> pkg::foo(x, y)\n```\n:::\n\n\n### Unquoting a missing forms\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-43_376495939d2c84ce2b8d48c236f46e61'}\n\n```{.r .cell-code}\narg <- missing_arg()\nexpr(foo(!!maybe_missing(arg), !!maybe_missing(arg)))\n#> foo(, )\n```\n:::\n\n\n### Unquoting in special forms\n\nThere are a few special forms where unquoting is a syntax error. Take `$` for example: it must always be followed by the name of a variable, not another expression.\n\nTo make unquoting work, you’ll need to use the prefix form:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-44_77bdbcaeed0458a8bdaab439ffa6c7bc'}\n\n```{.r .cell-code}\nx <- expr(x)\nexpr(`$`(df, !!x))\n#> df$x\n```\n:::\n\n\n### Unquoting many arguments\n\n`!!` is a one-to-one replacement. `!!!` (called “unquote-splice”, and pronounced bang-bang-bang) is a one-to-many replacement. It takes a list of expressions and inserts them at the location of the `!!!`:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-45_dd8c49831c25bbd353788ff57e93fa61'}\n\n```{.r .cell-code}\nxs <- exprs(1, a, -b)\nexpr(f(!!!xs, y))\n#> f(1, a, -b, y)\n\n# Or with names\nys <- set_names(xs, letters[1:3])\nexpr(f(!!!ys, d = 4))\n#> f(a = 1, b = a, c = -b, d = 4)\n```\n:::\n\n\n`!!!` can be used in any rlang function that takes `...` regardless of whether or not `...` is quoted or evaluated. We’ll come back to this in Section 19.6; for now note that this can be useful in `call2()`.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-46_77a95d67f1ffc2a010019ef3b7143c24'}\n\n```{.r .cell-code}\ncall2(\"f\", !!!xs, expr(y))\n#> f(1, a, -b, y)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n::: {.callout-tip title=\"To be continued\"}\n- <https://adv-r.hadley.nz/quasiquotation.html#non-standard-ast>\n:::\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}