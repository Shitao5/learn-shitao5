{
  "hash": "a77bdf320b792643922bff0aa8a2778e",
  "result": {
    "markdown": "---\ntitle: \"Mastering Shiny\"\ndate: \"2024-01-19\"\ndate-modified: \"2024-01-22\"\nimage: \"cover.png\"\ncategories: \n  - R\n---\n\n\n\n\n::: {.callout-note title='Progress'}\nLearning Progress: 43.48%.\n\n<!-- 读后感：[读《管理行为》](https://shitao5.org/posts/glxw/)。 -->\n:::\n\n::: {.callout-tip title=\"Learning Source\"}\n- <https://mastering-shiny.org/>\n- <https://rstudio.github.io/cheatsheets/html/shiny.html>\n:::\n\n# Getting started {-}\n\n# Your first Shiny app\n\n- You can enter that URL into any compatible web browser to open another copy of your app.\n\n- Layout functions, inputs, and outputs have different uses, but they are fundamentally the same under the covers: they’re all just fancy ways to generate HTML, and if you call any of them outside of a Shiny app, you’ll see HTML printed out at the console. Don’t be afraid to poke around to see how these various layouts and controls work under the hood.\n\n- The essence of reactivity: outputs automatically react (recalculate) when their inputs change.\n\n- In every kind of programming, it’s poor practice to have duplicated code; it can be computationally wasteful, and more importantly, it increases the difficulty of maintaining or debugging the code.\n\n- You create a reactive expression by wrapping a block of code in `reactive({...})` and assigning it to a variable, and you use a reactive expression by calling it like a function. But while it looks like you’re calling a function, a reactive expression has an important difference: it only runs the first time it is called and then it caches its result until it needs to be updated.\n\n# Basic UI\n\n- Generally, I recommend only using sliders for small ranges, or cases where the precise value is not so important. Attempting to precisely select a number on a small slider is an exercise in frustration!\n\n- By default, `plotOutput()` will take up the full width of its container (more on that shortly), and will be 400 pixels high. You can override these defaults with the `height` and `width` arguments. We recommend always setting `res = 96` as that will make your Shiny plots match what you see in RStudio as closely as possible.\n\n# Basic reactivity\n\n- The key idea of reactive programming is to specify a graph of dependencies so that when an input changes, all related outputs are automatically updated.\n\n- The `ui` is simple because every user gets the same HTML. The `server` is more complicated because every user needs to get an independent version of the app; when user A moves a slider, user B shouldn’t see their outputs change.\n  \n  To achieve this independence, Shiny invokes your `server()` function each time a new session starts. Just like any other R function, when the server function is called it creates a new local environment that is independent of every other invocation of the function. This allows each session to have a unique state, as well as isolating the variables created inside the function. This is why almost all of the reactive programming you’ll do in Shiny will be inside the server function.\n\n- Unlike a typical list, `input` objects are read-only. If you attempt to modify an input inside the server function, you’ll get an error.\n\n- One more important thing about `input`: it’s selective about who is allowed to read it. To read from an `input`, you must be in a **reactive context** created by a function like `renderText()` or `reactive()`. It’s an important constraint that allows outputs to automatically update when an input changes.\n\n- It’s important to understand that the order your code run is solely determined by the reactive graph. This is different from most R code where the execution order is determined by the order of lines.\n\n- In Shiny, however, I think you should consider the rule of one: whenever you copy and paste something *once*, you should consider extracting the repeated code out into a reactive expression. The rule is stricter for Shiny because reactive expressions don’t just make it easier for humans to understand the code, they also improve Shiny’s ability to efficiently rerun code.\n\n# Shiny in action {-}\n\n# Workflow\n\n- Improving workflow is a good place to invest time because it tends to pay great dividends in the long run. It doesn’t just increase the proportion of your time spent writing R code, but because you see the results more quickly, it makes the process of writing Shiny apps more enjoyable, and helps your skills improve more quickly.\n\n- The basic idea of print debugging is to call `print()` whenever you need to understand when a part of your code is evaluated, and to show the values of important variables. We call this “print” debugging (because in most languages you’d use a print function), but In R it makes more sense to use `message()` :\n  \n  - `print()` is designed for displaying vectors of data so it puts quotes around strings and starts the first line with `[1]`.\n  \n  - `message()` sends its result to “standard error”, rather than “standard output”. These are technical terms describing output streams, which you don’t normally notice because they’re both displayed in the same way when running interactively. But if your app is hosted elsewhere, then output sent to “standard error” will be recorded in the logs.\n\n# Layout, themes, HTML\n\n# Graphics\n\n- <p>For hosted apps, you also have to take into account the time needed to transmit the event from the browser to R, and then the rendered plot back from R to the browser.</p>\n\n# User feedback\n\n- An even simpler alternative is to use the [shinycssloaders](https://github.com/daattali/shinycssloaders) package by Dean Attali. It uses JavaScript to listen to Shiny events, so it doesn’t even need any code on the server side. Instead, you just use `shinycssloaders::withSpinner()` to wrap outputs that you want to automatically get a spinner when they have been invalidated.\n\n- There are a few small, but important, details to consider when creating a dialog box:\n  \n  - What should you call the buttons? It’s best to be descriptive, so avoid yes/no or continue/cancel in favour of recapitulating the key verb.\n  \n  - How should you order the buttons? Do you put cancel first (like the Mac), or continue first (like Windows)? Your best option is to mirror the platform that you think most people will be using.\n  \n  - Can you make the dangerous option more obvious? Here I’ve used `class = \"btn btn-danger\"` to style the button prominently.\n\n# Uploads and downloads\n\n- By default, the user can only upload files up to 5 MB. You can increase this limit by setting the `shiny.maxRequestSize` option prior to starting Shiny. For example, to allow up to 10 MB run `options(shiny.maxRequestSize = 10 * 1024^2)`.\n\n- I recommend using `.tsv` (tab separated value) instead of `.csv` (comma separated values) because many European countries use commas to separate the whole and fractional parts of a number (e.g. `1,23` vs `1.23`). This means `they can’t use commas to separate fields and instead use semi-colons in so-called “c”sv files! You can avoid this complexity by using tab separated files, which work the same way everywhere.\n\n- By default, RMarkdown will render the report in the current process, which means that it will inherit many settings from the Shiny app (like loaded packages, options, etc). For greater robustness, I recommend running `render()` in a separate R session using the callr package:\n\n\n  ::: {.cell layout-align=\"center\"}\n  \n  ```{.r .cell-code}\n  render_report <- function(input, output, params) {\n    rmarkdown::render(input,\n      output_file = output,\n      params = params,\n      envir = new.env(parent = globalenv())\n    )\n  }\n  \n  server <- function(input, output) {\n    output$report <- downloadHandler(\n      filename = \"report.html\",\n      content = function(file) {\n        params <- list(n = input$slider)\n        callr::r(\n          render_report,\n          list(input = report_path, output = file, params = params)\n        )\n      }\n    )\n  }\n  ```\n  :::\n\n\n# Dynamic UI\n\n- There are three key techniques for creating dynamic user interfaces:\n  \n  - Using the `update` family of functions to modify parameters of input controls.\n  \n  - Using `tabsetPanel()` to conditionally show and hide parts of the user interface.\n  \n  - Using `uiOutput()` and `renderUI()` to generate selected parts of the user interface with code.\n\n- You might wonder when you should use `freezeReactiveValue()`: it’s actually good practice to **always** use it when you dynamically change an input `value`. The actual modification takes some time to flow to the browser then back to Shiny, and in the interim any reads of the value are at best wasted, and at worst lead to errors. Use `freezeReactiveValue()` to tell all downstream calculations that an input value is stale and they should save their effort until it’s useful.\n\n- If you run this code yourself, you’ll notice that it takes a fraction of a second to appear after the app loads. That’s because it’s reactive: the app must load, trigger a reactive event, which calls the server function, yielding HTML to insert into the page. This is one of the downsides of `renderUI()`; relying on it too much can create a laggy UI. For good performance, strive to keep fixed as much of the user interface as possible, using the techniques described earlier in the chapter.\n  \n  There’s one other problem with this approach: when you change controls, you lose the currently selected value. Maintaining existing state is one of the big challenges of creating UI with code. This is one reason that selectively showing and hiding UI is a better approach if it works for you — because you’re not destroying and recreating the controls, you don’t need to do anything to preserve the values. However, in many cases, we can fix the problem by setting the value of the new input to the current `value` of the existing control:\n\n\n  ::: {.cell layout-align=\"center\"}\n  \n  ```{.r .cell-code}\n  server <- function(input, output, session) {\n    output$numeric <- renderUI({\n      value <- isolate(input$dynamic)\n      if (input$type == \"slider\") {\n        sliderInput(\"dynamic\", input$label, value = value, min = 0, max = 10)\n      } else {\n        numericInput(\"dynamic\", input$label, value = value, min = 0, max = 10)\n      }\n    })\n  }\n  ```\n  :::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}